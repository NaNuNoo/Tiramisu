
// Generated by CoffeeScript 1.11.1
(function() {
  window.M = {
    PI: Math.PI,
    PIx2: Math.PI * 2,
    PI_2: Math.PI / 2,
    PI_3: Math.PI / 3,
    PI_4: Math.PI / 4,
    PI_6: Math.PI / 6,
    E: Math.E,
    Ex2: Math.E,
    E_2: Math.E,
    SQRT2: Math.sqrt(2),
    SQRT3: Math.sqrt(3),
    SQRT5: Math.sqrt(5),
    SQRT2_2: Math.sqrt(2) / 2,
    SQRT3_2: Math.sqrt(3) / 2,
    SQRT5_2: Math.sqrt(5) / 2,
    SQRT3_3: Math.sqrt(3) / 3
  };

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  var nextTick, updateAnime;

  nextTick = function(func) {
    setTimeout(0, func);
  };

  updateAnime = (function() {
    var requestAnime, winRequestAnime;
    winRequestAnime = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || null;
    if ('function' === typeof winRequestAnime) {
      requestAnime = winRequestAnime.bind(window);
    } else {
      requestAnime = (function() {
        var lastTime;
        lastTime = 0;
        return function(callback) {
          var currentTime, timeToCall;
          currentTime = (new Date()).getTime();
          timeToCall = Math.max(0, 16 - (currentTime - lastTime));
          lastTime = currentTime + timeToCall;
          return setTimeout(function() {
            return callback(lastTime * 1000);
          }, timeToCall);
        };
      })();
    }
    return function(func) {
      var wrapFunc;
      wrapFunc = function() {
        func();
        return requestAnime(wrapFunc);
      };
      requestAnime(wrapFunc);
    };
  })();

  window.util = {
    nextTick: nextTick,
    updateAnime: updateAnime
  };

}).call(this);
function createWebGLWrap(argCanvas, argParam){
// Generated by CoffeeScript 1.11.1
var BufferIdx, BufferMesh, BufferUsage, BufferVtx, CHAR_FLOAT, CHAR_INDEX, CHAR_INT, CHAR_SIZE, CHAR_TABLE, DrawMode, GLSLType, GLSLVar, IndexType, NORMAL_STRIDE, Shader, SurfaceFormat, TEXTURE_STRIDE, Texture2D, TextureCube, TextureFilter, TextureFormat, TextureWrap, VERTEX_STRIDE, bindAttributeBuffer, bindAttributeConst, bindUniform, clearFrame, createBufferIdx_Array, createBufferIdx_Size, createBufferMesh_Obj, createBufferVtx_Array, createBufferVtx_Size, createContext, createShader, createTexture2DHelper, createTexture2D_Data, createTexture2D_Image, createTexture2D_Size, createTextureCubeHelper, createTextureCube_Data, createTextureCube_Image, createTextureCube_Size, destoryBufferIdx, destoryBufferMesh, destoryBufferVtx, destoryShader, destoryTexture2D, destoryTextureCube, drawCall, glState, ignoreLine, ignoreSpace, imagePromise, objFile, parseFloatEx, parseIntEx, parseNormal, parseTexture, parseThird, parseVertex, webGL, writeIndex, xhrPromise,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

webGL = argCanvas.getContext("webgl", argParam) || argCanvas.getContext("experimental-webgl", argParam) || argCanvas.getContext("webkit-3d", argParam) || argCanvas.getContext("moz-webgl", argParam) || argCanvas.getContext("webkit-webgl", argParam) || argCanvas.getContext("ms-webgl", argParam) || argCanvas.getContext("o-webgl", argParam);

if (!webGL) {
  return null;
}

TextureFormat = function(name, glFormat, glMemeory) {
  this.name = name;
  this.glFormat = glFormat;
  this.glMemeory = glMemeory;
  Object.freeze(this);
};

TextureFormat.prototype.toString = function() {
  return this.name;
};

TextureFormat.R4G4B4A4 = new TextureFormat("R4G4B4A4", webGL.RGBA, webGL.UNSIGNED_SHORT_4_4_4_4);

TextureFormat.R5G5B5A1 = new TextureFormat("R5G5B5A1", webGL.RGBA, webGL.UNSIGNED_SHORT_5_5_5_1);

TextureFormat.R5G6B5 = new TextureFormat("R5G6B5", webGL.RGB, webGL.UNSIGNED_SHORT_5_6_5);

TextureFormat.L8 = new TextureFormat("L8", webGL.LUMINANCE, webGL.UNSIGNED_BYTE);

TextureFormat.A8 = new TextureFormat("A8", webGL.ALPHA, webGL.UNSIGNED_BYTE);

TextureFormat.L8A8 = new TextureFormat("L8A8", webGL.LUMINANCE_ALPHA, webGL.UNSIGNED_BYTE);

TextureFormat.R8G8B8 = new TextureFormat("R8G8B8", webGL.RGB, webGL.UNSIGNED_BYTE);

TextureFormat.R8G8B8A8 = new TextureFormat("R8G8B8A8", webGL.RGBA, webGL.UNSIGNED_BYTE);

TextureWrap = function(name, glCode) {
  this.name = name;
  this.glCode = glCode;
  Object.freeze(this);
};

TextureWrap.prototype.toString = function() {
  return this.name;
};

TextureWrap.REPEAT = new TextureWrap("REPEAT", webGL.REPEAT);

TextureWrap.EDGE = new TextureWrap("EDGE", webGL.CLAMP_TO_EDGE);

TextureWrap.MIRROR = new TextureWrap("MIRROR", webGL.MIRRORED_REPEAT);

TextureFilter = function(name, glCode) {
  this.name = name;
  this.glCode = glCode;
  Object.freeze(this);
};

TextureFilter.prototype.toString = function() {
  return this.name;
};

TextureFilter.NEAREST = new TextureFilter("NEAREST", webGL.NEAREST);

TextureFilter.LINEAR = new TextureFilter("LINEAR", webGL.LINEAR);

TextureFilter.NEAREST_NEAREST = new TextureFilter("NEAREST_NEAREST", webGL.NEAREST_MIPMAP_NEARESTA);

TextureFilter.NEAREST_LINEAR = new TextureFilter("NEAREST_LINEAR", webGL.NEAREST_MIPMAP_LINEAR);

TextureFilter.LINEAR_NEAREST = new TextureFilter("LINEAR_NEAREST", webGL.LINEAR_MIPMAP_NEAREST);

TextureFilter.LINEAR_LINEAR = new TextureFilter("LINEAR_LINEAR", webGL.LINEAR_MIPMAP_LINEAR);

SurfaceFormat = function(name, glCode) {
  this.name = name;
  this.glCode = glCode;
  Object.freeze(this);
};

SurfaceFormat.prototype.toString = function() {
  return this.name;
};

BufferUsage = function(name, glCode) {
  this.name = name;
  this.glCode = glCode;
  Object.freeze(this);
};

BufferUsage.prototype.toString = function() {
  return this.name;
};

BufferUsage.STATIC = new BufferUsage("STATIC", webGL.STATIC_DRAW);

BufferUsage.DYNAMIC = new BufferUsage("DYNAMIC", webGL.DYNAMIC_DRAW);

BufferUsage.STREAM = new BufferUsage("STREAM", webGL.STREAM_DRAW);

IndexType = function(name, glCode) {
  this.name = name;
  this.glCode = glCode;
  Object.freeze(this);
};

IndexType.prototype.toString = function() {
  return this.name;
};

IndexType.BYTE = new IndexType("BYTE", webGL.BYTE);

IndexType.SHORT = new IndexType("SHORT", webGL.SHORT);

DrawMode = function(name, glCode) {
  this.name = name;
  this.glCode = glCode;
  Object.freeze(this);
};

DrawMode.prototype.toString = function() {
  return this.name;
};

DrawMode.POINTS = new DrawMode("POINTS", webGL.POINTS);

DrawMode.LINE_STRIP = new DrawMode("LINE_STRIP", webGL.LINE_STRIP);

DrawMode.LINE_LOOP = new DrawMode("LINE_LOOP", webGL.LINE_LOOP);

DrawMode.LINES = new DrawMode("LINES", webGL.LINES);

DrawMode.TRIANGLE_STRIP = new DrawMode("TRIANGLE_STRIP", webGL.TRIANGLE_STRIP);

DrawMode.TRIANGLE_FAN = new DrawMode("TRIANGLE_FAN", webGL.TRIANGLE_FAN);

DrawMode.TRIANGLES = new DrawMode("TRIANGLES", webGL.TRIANGLES);

GLSLType = function(typeIndex, typeName, typeCode, unitBytes, unitCount) {
  this.typeIndex = typeIndex;
  this.typeName = typeName;
  this.typeCode = typeCode;
  this.unitBytes = unitBytes;
  this.unitCount = unitCount;
  Object.freeze(this);
};

GLSLType.fromGLType = function(webGLType) {
  switch (webGLType) {
    case webGL.BOOL:
      return GLSLType.BOOL;
    case webGL.BOOL_VEC2:
      return GLSLType.BVEC2;
    case webGL.BOOL_VEC3:
      return GLSLType.BVEC3;
    case webGL.BOOL_VEC4:
      return GLSLType.BVEC4;
    case webGL.INT:
      return GLSLType.INT;
    case webGL.INT_VEC2:
      return GLSLType.IVEC2;
    case webGL.INT_VEC3:
      return GLSLType.IVEC3;
    case webGL.INT_VEC4:
      return GLSLType.IVEC4;
    case webGL.FLOAT:
      return GLSLType.FLOAT;
    case webGL.FLOAT_VEC2:
      return GLSLType.VEC2;
    case webGL.FLOAT_VEC3:
      return GLSLType.VEC3;
    case webGL.FLOAT_VEC4:
      return GLSLType.VEC4;
    case webGL.FLOAT_MAT2:
      return GLSLType.MAT2;
    case webGL.FLOAT_MAT3:
      return GLSLType.MAT3;
    case webGL.FLOAT_MAT4:
      return GLSLType.MAT4;
    case webGL.SAMPLER_2D:
      return GLSLType.SAMPLER_2D;
    case webGL.SAMPLER_CUBE:
      return GLSLType.SAMPLER_Cube;
    default:
      return null;
  }
};

GLSLType.BOOL = new GLSLType(0, "bool", webGL.BOOL, 1, 1);

GLSLType.BVEC2 = new GLSLType(1, "bvec2", webGL.BOOL, 1, 2);

GLSLType.BVEC3 = new GLSLType(2, "bvec3", webGL.BOOL, 1, 3);

GLSLType.BVEC4 = new GLSLType(3, "bvec4", webGL.BOOL, 1, 4);

GLSLType.INT = new GLSLType(4, "int", webGL.INT, 4, 1);

GLSLType.IVEC2 = new GLSLType(5, "ivec2", webGL.INT, 4, 2);

GLSLType.IVEC3 = new GLSLType(6, "ivec3", webGL.INT, 4, 3);

GLSLType.IVEC4 = new GLSLType(7, "ivec4", webGL.INT, 4, 4);

GLSLType.FLOAT = new GLSLType(8, "float", webGL.FLOAT, 4, 1);

GLSLType.VEC2 = new GLSLType(9, "vec2", webGL.FLOAT, 4, 2);

GLSLType.VEC3 = new GLSLType(10, "vec3", webGL.FLOAT, 4, 3);

GLSLType.VEC4 = new GLSLType(11, "vec4", webGL.FLOAT, 4, 4);

GLSLType.MAT2 = new GLSLType(12, "mat2", webGL.FLOAT, 4, 4);

GLSLType.MAT3 = new GLSLType(13, "mat3", webGL.FLOAT, 4, 9);

GLSLType.MAT4 = new GLSLType(14, "mat4", webGL.FLOAT, 4, 16);

GLSLType.SAMPLER_2D = new GLSLType(15, "sampler2d", webGL.SAMPLER_2D, 4, 1);

GLSLType.SAMPLER_CUBE = new GLSLType(16, "samplerCube", webGL.SAMPLER_CUBE, 4, 1);

GLSLVar = function(info, location) {
  this.varName = info.name;
  this.location = location;
  this.typeInfo = GLSLType.fromGLType(info.type);
  this.arraySize = info.size;
};

GLSLVar.prototype.toString = function() {
  return this.typeInfo + " " + this.varName;
};

Shader = function() {
  this._hShader = null;
  this._uniformNum = 0;
  this._uniformMap = Object.create(null);
  this._attributeNum = 0;
  this._attributeMap = Object.create(null);
};

Shader.prototype.getUniformNum = function() {
  return this._uniformNum;
};

Shader.prototype.getUniformName = function(name) {
  return this._uniformMap[name];
};

Shader.prototype.getAttributeNum = function() {
  return this._attributeNum;
};

Shader.prototype.getAttributeName = function(name) {
  return this._attributeMap[name];
};

createShader = function(vsCode, fsCode) {
  return new Promise(function(resolve, reject) {
    var hFragment, hShader, hVertex, i, idx, info, infoLog, isOk, j, location, ref, ref1, shader;
    isOk = false;
    while (true) {
      hVertex = webGL.createShader(webGL.VERTEX_SHADER);
      if (!hVertex) {
        console.error("Create shader ERR.");
        break;
      }
      webGL.shaderSource(hVertex, vsCode);
      webGL.compileShader(hVertex);
      if (!webGL.getShaderParameter(hVertex, webGL.COMPILE_STATUS)) {
        infoLog = webGL.getShaderInfoLog(hVertex);
        console.error("Vertex Shader ERR." + infoLog);
        break;
      }
      hFragment = webGL.createShader(webGL.FRAGMENT_SHADER);
      if (!hFragment) {
        console.error("Create shader ERR.");
        break;
      }
      webGL.shaderSource(hFragment, fsCode);
      webGL.compileShader(hFragment);
      if (!webGL.getShaderParameter(hFragment, webGL.COMPILE_STATUS)) {
        infoLog = webGL.getShaderInfoLog(hFragment);
        console.error("Fragment Shader ERR." + infoLog);
        break;
      }
      hShader = webGL.createProgram();
      if (!hShader) {
        console.error("Create Program ERR.");
        break;
      }
      webGL.attachShader(hShader, hVertex);
      webGL.attachShader(hShader, hFragment);
      webGL.linkProgram(hShader);
      if (!webGL.getProgramParameter(hShader, webGL.LINK_STATUS)) {
        infoLog = webGL.getProgramInfoLog(hShader);
        console.error("Shader Link ERR.\n" + infoLog);
        break;
      }
      isOk = true;
      break;
    }
    if (hVertex) {
      webGL.deleteShader(hVertex);
    }
    if (hFragment) {
      webGL.deleteShader(hFragment);
    }
    if (!isOk) {
      if (hShader) {
        webGL.deleteProgram(hShader);
      }
      return reject(new Error("createShader() ERR."));
    }
    shader = new Shader();
    shader._hShader = hShader;
    shader._uniformNum = webGL.getProgramParameter(hShader, webGL.ACTIVE_UNIFORMS);
    for (idx = i = 0, ref = shader._uniformNum; i < ref; idx = i += 1) {
      info = webGL.getActiveUniform(hShader, idx);
      location = webGL.getUniformLocation(hShader, info.name);
      shader._uniformMap[info.name] = new GLSLVar(info, location);
    }
    shader._attributeNum = webGL.getProgramParameter(hShader, webGL.ACTIVE_ATTRIBUTES);
    for (idx = j = 0, ref1 = shader._attributeNum; j < ref1; idx = j += 1) {
      info = webGL.getActiveAttrib(hShader, idx);
      location = webGL.getAttribLocation(hShader, info.name);
      shader._attributeMap[info.name] = new GLSLVar(info, location);
    }
    return resolve(shader);
  });
};

destoryShader = function(shader) {
  if (shader._hShader) {
    webGL.deleteProgram(shader._hShader);
  }
  shader._hShader = null;
  shader._uniformNum = 0;
  shader._uniformMap = null;
  shader._attributeNum = 0;
  shader._attributeMap = null;
};

CHAR_INT = 0x1;

CHAR_INDEX = 0x2;

CHAR_FLOAT = 0x4;

CHAR_SIZE = 128;

CHAR_TABLE = new Uint32Array(CHAR_SIZE);

CHAR_TABLE[45] = CHAR_FLOAT;

CHAR_TABLE[46] = CHAR_FLOAT;

CHAR_TABLE[47] = CHAR_INDEX;

CHAR_TABLE[48] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;

CHAR_TABLE[49] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;

CHAR_TABLE[50] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;

CHAR_TABLE[51] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;

CHAR_TABLE[52] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;

CHAR_TABLE[53] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;

CHAR_TABLE[54] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;

CHAR_TABLE[55] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;

CHAR_TABLE[56] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;

CHAR_TABLE[57] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;

CHAR_TABLE[69] = CHAR_FLOAT;

CHAR_TABLE[101] = CHAR_FLOAT;

VERTEX_STRIDE = 3;

TEXTURE_STRIDE = 2;

NORMAL_STRIDE = 3;

createContext = function() {
  return {
    vertex: new Array(512 * VERTEX_STRIDE),
    vertexLen: 0,
    texture: new Array(512 * TEXTURE_STRIDE),
    textureLen: 0,
    normal: new Array(512 * NORMAL_STRIDE),
    normalLen: 0,
    initFlag: false,
    vertexStride: 0,
    textureStride: 0,
    normalStride: 0,
    totalStride: 0,
    vtxBuf: null,
    vtxBufLen: 0,
    idxBuf: null,
    idxBufLen: 0,
    idxMap: Object.create(null)
  };
};

ignoreSpace = function(text, ptr) {
  if (' ' !== text[ptr] && '\t' !== text[ptr]) {
    throw new Error();
  }
  ptr = ptr + 1;
  while (' ' === text[ptr] || '\t' === text[ptr]) {
    ptr = ptr + 1;
  }
  return ptr;
};

ignoreLine = function(text, ptr) {
  while (void 0 !== text[ptr]) {
    if ('\r' === text[ptr]) {
      if ('\r' !== text[ptr + 1]) {
        ptr = ptr + 1;
      } else {
        ptr = ptr + 2;
      }
      break;
    }
    if ('\n' === text[ptr]) {
      if ('\r' !== text[ptr + 1]) {
        ptr = ptr + 1;
      } else {
        ptr = ptr + 2;
      }
      break;
    }
    ptr = ptr + 1;
  }
  return ptr;
};

parseIntEx = (function() {
  var result;
  result = {
    ptr: 0,
    num: 0
  };
  return function(text, ptr) {
    var charCode, start;
    start = ptr;
    charCode = text.charCodeAt(ptr);
    if ((charCode >= CHAR_SIZE) || (0 === (CHAR_INT & CHAR_TABLE[charCode]))) {
      throw new Error();
    }
    ptr = ptr + 1;
    while (true) {
      charCode = text.charCodeAt(ptr);
      if ((charCode >= CHAR_SIZE) || (0 === (CHAR_INT & CHAR_TABLE[charCode]))) {
        break;
      }
      ptr = ptr + 1;
    }
    result.ptr = ptr;
    result.num = parseInt(text.slice(start, ptr));
    return result;
  };
})();

parseFloatEx = (function() {
  var result;
  result = {
    ptr: 0,
    num: 0
  };
  return function(text, ptr) {
    var charCode, start;
    start = ptr;
    charCode = text.charCodeAt(ptr);
    if ((charCode >= CHAR_SIZE) || (0 === (CHAR_FLOAT & CHAR_TABLE[charCode]))) {
      throw new Error();
    }
    ptr = ptr + 1;
    while (true) {
      charCode = text.charCodeAt(ptr);
      if ((charCode >= CHAR_SIZE) || (0 === (CHAR_FLOAT & CHAR_TABLE[charCode]))) {
        break;
      }
      ptr = ptr + 1;
    }
    result.ptr = ptr;
    result.num = parseFloat(text.slice(start, ptr));
    return result;
  };
})();

parseVertex = (function() {
  var result;
  result = {
    ptr: 0,
    vx: 0,
    vy: 0,
    vz: 0
  };
  return function(text, ptr) {
    var ref, ref1, ref2;
    ptr = ignoreSpace(text, ptr);
    ref = parseFloatEx(text, ptr), result.vx = ref.num, ptr = ref.ptr;
    ptr = ignoreSpace(text, ptr);
    ref1 = parseFloatEx(text, ptr), result.vy = ref1.num, ptr = ref1.ptr;
    ptr = ignoreSpace(text, ptr);
    ref2 = parseFloatEx(text, ptr), result.vz = ref2.num, ptr = ref2.ptr;
    result.ptr = ignoreLine(text, ptr);
    return result;
  };
})();

parseTexture = (function() {
  var result;
  result = {
    ptr: 0,
    tx: 0,
    ty: 0
  };
  return function(text, ptr) {
    var ref, ref1;
    ptr = ignoreSpace(text, ptr);
    ref = parseFloatEx(text, ptr), result.tx = ref.num, ptr = ref.ptr;
    ptr = ignoreSpace(text, ptr);
    ref1 = parseFloatEx(text, ptr), result.ty = ref1.num, ptr = ref1.ptr;
    result.ptr = ignoreLine(text, ptr);
    return result;
  };
})();

parseNormal = (function() {
  var result;
  result = {
    ptr: 0,
    nx: 0,
    ny: 0,
    nz: 0
  };
  return function(text, ptr) {
    var ref, ref1, ref2;
    ptr = ignoreSpace(text, ptr);
    ref = parseFloatEx(text, ptr), result.nx = ref.num, ptr = ref.ptr;
    ptr = ignoreSpace(text, ptr);
    ref1 = parseFloatEx(text, ptr), result.ny = ref1.num, ptr = ref1.ptr;
    ptr = ignoreSpace(text, ptr);
    ref2 = parseFloatEx(text, ptr), result.nz = ref2.num, ptr = ref2.ptr;
    result.ptr = ignoreLine(text, ptr);
    return result;
  };
})();

parseThird = (function() {
  var result;
  result = {
    ptr: 0,
    idxText: ""
  };
  return function(text, ptr) {
    var charCode, start;
    start = ptr;
    while (true) {
      charCode = text.charCodeAt(ptr);
      if (0 === (CHAR_INDEX & CHAR_TABLE[charCode])) {
        break;
      }
      ptr = ptr + 1;
    }
    result.ptr = ptr;
    result.idxText = text.slice(start, ptr);
    if ('' === result.idxText) {
      throw new Error();
    }
    return result;
  };
})();

writeIndex = function(ctx, idxText) {
  var ni, numArray, offset, ptr, ref, ref1, ref2, ti, vi;
  numArray = idxText.split('/');
  if (!ctx.initFlag) {
    ctx.initFlag = true;
    ctx.totalStride = 0;
    if ('' !== numArray[0] && void 0 !== numArray[0]) {
      ctx.vertexStride = VERTEX_STRIDE;
      ctx.totalStride = ctx.totalStride + VERTEX_STRIDE;
    }
    if ('' !== numArray[1] && void 0 !== numArray[1]) {
      ctx.textureStride = TEXTURE_STRIDE;
      ctx.totalStride = ctx.totalStride + TEXTURE_STRIDE;
    }
    if ('' !== numArray[2] && void 0 !== numArray[2]) {
      ctx.normalStride = NORMAL_STRIDE;
      ctx.totalStride = ctx.totalStride + NORMAL_STRIDE;
    }
    ctx.vtxBuf = new Array(ctx.totalStride * 512);
    ctx.idxBuf = new Array(4 * 512);
  }
  if (indexOf.call(ctx.idxMap, idxText) >= 0) {
    ctx.idxBuf[ctx.idxBufLen++] = ctx.idxMap[idxText];
    return;
  }
  ptr = 0;
  offset = 0;
  if (ctx.vertexStride) {
    ref = parseIntEx(idxText, ptr), ptr = ref.ptr, vi = ref.num;
    vi = vi - 1;
    if (vi > ctx.vertexLen) {
      throw new Error();
    }
    ctx.vtxBuf[ctx.totalStride * ctx.vtxBufLen + offset++] = ctx.vertex[VERTEX_STRIDE * vi + 0];
    ctx.vtxBuf[ctx.totalStride * ctx.vtxBufLen + offset++] = ctx.vertex[VERTEX_STRIDE * vi + 1];
    ctx.vtxBuf[ctx.totalStride * ctx.vtxBufLen + offset++] = ctx.vertex[VERTEX_STRIDE * vi + 2];
  }
  if (ctx.textureStride) {
    if ('/' !== idxText[ptr]) {
      throw new Error();
    }
    ptr = ptr + 1;
    ref1 = parseIntEx(idxText, ptr), ptr = ref1.ptr, ti = ref1.num;
    ti = ti - 1;
    if (ti > ctx.textureLen) {
      throw new Error();
    }
    ctx.vtxBuf[ctx.totalStride * ctx.vtxBufLen + offset++] = ctx.texture[TEXTURE_STRIDE * ti + 0];
    ctx.vtxBuf[ctx.totalStride * ctx.vtxBufLen + offset++] = ctx.texture[TEXTURE_STRIDE * ti + 1];
  }
  if (ctx.normalStride) {
    if ('/' !== idxText[ptr]) {
      throw new Error();
    }
    ptr = ptr + 1;
    if ('/' === idxText[ptr]) {
      ptr = ptr + 1;
    }
    ref2 = parseIntEx(idxText, ptr), ptr = ref2.ptr, ni = ref2.num;
    ni = ni - 1;
    if (ni > ctx.normalLen) {
      throw new Error();
    }
    ctx.vtxBuf[ctx.totalStride * ctx.vtxBufLen + offset++] = ctx.normal[NORMAL_STRIDE * ni + 0];
    ctx.vtxBuf[ctx.totalStride * ctx.vtxBufLen + offset++] = ctx.normal[NORMAL_STRIDE * ni + 1];
    ctx.vtxBuf[ctx.totalStride * ctx.vtxBufLen + offset++] = ctx.normal[NORMAL_STRIDE * ni + 2];
  }
  if (ptr !== idxText.length) {
    throw new Error();
  }
  ctx.idxBuf[ctx.idxBufLen++] = ctx.vtxBufLen;
  ctx.idxMap[idxText] = ctx.vtxBufLen;
  ctx.vtxBufLen = ctx.vtxBufLen + 1;
};

objFile = function(text) {
  var ctx, idxText, nx, ny, nz, ptr, ref, ref1, ref2, ref3, ref4, ref5, textLen, tx, ty, vx, vy, vz;
  ctx = createContext();
  ptr = 0;
  textLen = text.length;
  while (ptr < textLen) {
    switch (text[ptr]) {
      case 'v':
        ptr = ptr + 1;
        if ('t' === text[ptr]) {
          ptr = ptr + 1;
          ref = parseTexture(text, ptr), ptr = ref.ptr, tx = ref.tx, ty = ref.ty;
          ctx.texture[TEXTURE_STRIDE * ctx.textureLen + 0] = tx;
          ctx.texture[TEXTURE_STRIDE * ctx.textureLen + 1] = ty;
          ctx.textureLen = ctx.textureLen + 1;
        } else if ('n' === text[ptr]) {
          ptr = ptr + 1;
          ref1 = parseNormal(text, ptr), ptr = ref1.ptr, nx = ref1.nx, ny = ref1.ny, nz = ref1.nz;
          ctx.normal[NORMAL_STRIDE * ctx.normalLen + 0] = nx;
          ctx.normal[NORMAL_STRIDE * ctx.normalLen + 1] = ny;
          ctx.normal[NORMAL_STRIDE * ctx.normalLen + 2] = nz;
          ctx.normalLen = ctx.normalLen + 1;
        } else {
          ref2 = parseVertex(text, ptr), ptr = ref2.ptr, vx = ref2.vx, vy = ref2.vy, vz = ref2.vz;
          ctx.vertex[VERTEX_STRIDE * ctx.vertexLen + 0] = vx;
          ctx.vertex[VERTEX_STRIDE * ctx.vertexLen + 1] = vy;
          ctx.vertex[VERTEX_STRIDE * ctx.vertexLen + 2] = vz;
          ctx.vertexLen = ctx.vertexLen + 1;
        }
        break;
      case 'f':
        ptr = ptr + 1;
        ptr = ignoreSpace(text, ptr);
        ref3 = parseThird(text, ptr), ptr = ref3.ptr, idxText = ref3.idxText;
        writeIndex(ctx, idxText);
        ptr = ignoreSpace(text, ptr);
        ref4 = parseThird(text, ptr), ptr = ref4.ptr, idxText = ref4.idxText;
        writeIndex(ctx, idxText);
        ptr = ignoreSpace(text, ptr);
        ref5 = parseThird(text, ptr), ptr = ref5.ptr, idxText = ref5.idxText;
        writeIndex(ctx, idxText);
        ptr = ignoreLine(text, ptr);
        break;
      case '#':
        ptr = ignoreLine(text, ptr);
        break;
      case 'g':
        ptr = ptr + 1;
        ptr = ignoreSpace(text, ptr);
        ptr = ignoreLine(text, ptr);
        break;
      case 'o':
        ptr = ptr + 1;
        ptr = ignoreSpace(text, ptr);
        ptr = ignoreLine(text, ptr);
        break;
      case 's':
        ptr = ptr + 1;
        ptr = ignoreSpace(text, ptr);
        ptr = ignoreLine(text, ptr);
        break;
      case 'm':
        if ('mtllib' !== text.slice(ptr, ptr + 6)) {
          throw new Error();
        }
        ptr = ptr + 6;
        ptr = ignoreSpace(text, ptr);
        ptr = ignoreLine(text, ptr);
        break;
      case 'u':
        if ('usemtl' !== text.slice(ptr, ptr + 6)) {
          throw new Error();
        }
        ptr = ptr + 6;
        ptr = ignoreSpace(text, ptr);
        ptr = ignoreLine(text, ptr);
        break;
      case '\r':
      case '\n':
        ptr = ignoreLine(text, ptr);
        break;
      case ' ':
      case '\t':
        ptr = ignoreSpace(text, ptr);
        ptr = ignoreLine(text, ptr);
        break;
      default:
        throw new Error();
    }
  }
  ctx.vtxBuf.length = ctx.vtxBufLen * ctx.totalStride;
  ctx.idxBuf.length = ctx.idxBufLen;
  return {
    vtxBuf: new Float32Array(ctx.vtxBuf),
    idxBuf: new Uint16Array(ctx.idxBuf),
    vertexStride: ctx.vertexStride,
    textureStride: ctx.textureStride,
    normalStride: ctx.normalStride
  };
};

BufferVtx = function() {
  this._hVertex = null;
  this._size = 0;
  this._usage = null;
};

BufferVtx.prototype.getUsage = function() {
  return this._usage;
};

BufferVtx.prototype.getSize = function() {
  return this._size;
};

createBufferVtx_Array = function(array, usage) {
  var bufferVtx;
  bufferVtx = new BufferVtx();
  bufferVtx._size = array.byteLength;
  bufferVtx._usage = usage;
  bufferVtx._hVertex = webGL.createBuffer();
  if (!bufferVtx._hVertex) {
    throw new Error("Create BufferVtx ERR.");
  }
  webGL.bindBuffer(webGL.ARRAY_BUFFER, bufferVtx._hVertex);
  webGL.bufferData(webGL.ARRAY_BUFFER, array, bufferVtx._usage.glCode);
  webGL.bindBuffer(webGL.ARRAY_BUFFER, null);
  return bufferVtx;
};

createBufferVtx_Size = function(size, usage) {
  var bufferVtx;
  bufferVtx = new BufferVtx();
  bufferVtx._size = size;
  bufferVtx._usage = usage || webGL.STATIC_DRAW;
  bufferVtx._hVertex = webGL.createBuffer();
  if (!bufferVtx._hVertex) {
    throw new Error("Create BufferVtx ERR.");
  }
  webGL.bindBuffer(webGL.ARRAY_BUFFER, bufferVtx._hVertex);
  webGL.bufferData(webGL.ARRAY_BUFFER, bufferVtc._size, bufferVtx._usage.glCode);
  webGL.bindBuffer(webGL.ARRAY_BUFFER, null);
  return bufferVtx;
};

destoryBufferVtx = function(bufferVtx) {
  if (bufferVtx._hVertex) {
    webGL.deleteBuffer(bufferVtx._hVertex);
  }
  bufferVtx._hVertex = null;
  bufferVtx._usage = null;
  bufferVtx._size = 0;
};

BufferIdx = function() {
  this._hIndex = null;
  this._usage = null;
  this._size = 0;
};

BufferIdx.prototype.getUsage = function() {
  return this._usage;
};

BufferIdx.prototype.getSize = function() {
  return this._size;
};

createBufferIdx_Array = function(array, usage) {
  var bufferIdx;
  bufferIdx = new BufferIdx();
  bufferIdx._size = array.size;
  bufferIdx._usage = usage;
  bufferIdx._hIndex = webGL.createBuffer();
  if (!bufferIdx._hIndex) {
    throw new Error("Create BufferIdx ERR.");
  }
  webGL.bindBuffer(webGL.ELEMENT_ARRAY_BUFFER, bufferIdx._hIndex);
  webGL.bufferData(webGL.ELEMENT_ARRAY_BUFFER, array, bufferIdx._usage.glCode);
  webGL.bindBuffer(webGL.ELEMENT_ARRAY_BUFFER, null);
  return bufferIdx;
};

createBufferIdx_Size = function(size, type, usage) {
  var bufferIdx;
  bufferIdx = new BufferIdx();
  bufferIdx._usage = usage;
  bufferIdx._size = size;
  bufferIdx._hIndex = webGL.createBuffer();
  if (!bufferIdx._hIndex) {
    throw new Error("Create BufferIdx ERR.");
  }
  webGL.bindBuffer(webGL.ELEMENT_ARRAY_BUFFER, bufferIdx._hIndex);
  webGL.bufferData(webGL.ELEMENT_ARRAY_BUFFER, bufferIdx._size, bufferIdx._usage);
  webGL.bindBuffer(webGL.ELEMENT_ARRAY_BUFFER, null);
  return bufferIdx;
};

destoryBufferIdx = function(bufferIdx) {
  if (bufferIdx._hIndex) {
    webGL.deleteBuffer(bufferIdx._hIndex);
  }
  bufferIdx._hIndex = null;
  bufferIdx._usage = null;
  bufferIdx._size = 0;
};

BufferMesh = function() {
  this._hVertex = null;
  this._hIndex = null;
  this._usage = BufferUsage.STATIC;
  this._vertexStride = 0;
  this._textureStride = 0;
  this._normalStride = 0;
  this._indexLength = 0;
};

BufferMesh.prototype.getIndexLength = function() {
  return this._indexLength;
};

xhrPromise = function(url) {
  return new Promise(function(resolve, reject) {
    var xhr;
    xhr = new XMLHttpRequest();
    xhr.onload = function() {
      return resolve(xhr.responseText);
    };
    xhr.onerror = function() {
      return reject(new Error("HTTP " + xhr.status + "."));
    };
    xhr.ontimeout = function() {
      return reject(new Error("HTTP time out."));
    };
    xhr.timeout = 5000;
    xhr.open("GET", url);
    return xhr.send(null);
  });
};

createBufferMesh_Obj = function(url) {
  return xhrPromise(url).then(function(objText) {
    return new Promise(function(resolve, reject) {
      var bufferMesh, objData;
      objData = objFile(objText);
      bufferMesh = new BufferMesh();
      bufferMesh._vertexStride = objData.vertexStride;
      bufferMesh._textureStride = objData.textureStride;
      bufferMesh._normalStride = objData.normalStride;
      bufferMesh._indexLength = objData.idxBuf.length;
      bufferMesh._hVertex = webGL.createBuffer();
      if (!bufferMesh._hVertex) {
        reject(new Error("Create BufferVtx ERR."));
      }
      webGL.bindBuffer(webGL.ARRAY_BUFFER, bufferMesh._hVertex);
      webGL.bufferData(webGL.ARRAY_BUFFER, objData.vtxBuf, bufferMesh._usage.glCode);
      webGL.bindBuffer(webGL.ARRAY_BUFFER, null);
      bufferMesh._hIndex = webGL.createBuffer();
      if (!bufferMesh._hIndex) {
        reject(new Error("Create BufferIdx ERR."));
      }
      webGL.bindBuffer(webGL.ELEMENT_ARRAY_BUFFER, bufferMesh._hIndex);
      webGL.bufferData(webGL.ELEMENT_ARRAY_BUFFER, objData.idxBuf, bufferMesh._usage.glCode);
      webGL.bindBuffer(webGL.ELEMENT_ARRAY_BUFFER, null);
      return resolve(bufferMesh);
    });
  });
};

destoryBufferMesh = function(bufferMesh) {
  if (bufferMesh._hVertex) {
    webGL.deleteBuffer(bufferMesh._hVertex);
  }
  bufferMesh._hVertex = null;
  if (bufferMesh._hIndex) {
    webGL.deleteBuffer(bufferMesh._hIndex);
  }
  bufferMesh._hIndex = null;
  bufferMesh._usage = BufferUsage.STATIC;
  bufferMesh._vertexStride = 0;
  bufferMesh._textureStride = 0;
  bufferMesh._normalStride = 0;
  bufferMesh._indexLength = 0;
};

imagePromise = function(url) {
  return new Promise(function(resolve, reject) {
    var image;
    image = new Image();
    image.onload = function() {
      return resolve(image);
    };
    image.onerror = function() {
      return reject(new Error("Load Image ERR."));
    };
    return image.src = url;
  });
};

Texture2D = function() {
  this._hTexture = null;
  this._width = 0;
  this._height = 0;
  this._format = null;
  this._wrapS = null;
  this._wrapT = null;
  this._magFilter = null;
  this._minFilter = null;
  this._mipMap = false;
};

createTexture2DHelper = function(isImageObj) {
  var glFormat, glMemory, height, image, param, ref, texture2D, width;
  if (isImageObj) {
    image = arguments[1];
    param = arguments[2] || {};
  } else {
    width = arguments[1];
    height = arguments[2];
    param = arguments[3] || {};
  }
  texture2D = new Texture2D();
  texture2D._format = param.format || TextureFormat.RGBA;
  texture2D._wrapS = param.wrapS || TextureWrap.EDGE;
  texture2D._wrapT = param.wrapT || TextureWrap.EDGE;
  texture2D._magFilter = param.magFilter || TextureFilter.LINEAR;
  texture2D._minFilter = param.minFilter || TextureFilter.LINEAR;
  texture2D._hTexture = webGL.createTexture();
  if (!texture._hTexture) {
    return null;
  }
  webGL.bindTexture(webGL.TEXTURE_2D, texture2D._hTexture);
  ref = texture2D._format, glMemory = ref.glMemory, glFormat = ref.glFormat;
  if (isImageObj) {
    webGL.texImage2D(webGL.TEXTURE_2D, 0, glMemory, glFormat, glMemory, image);
  } else {
    webGL.texImage2D(webGL.TEXTURE_2D, 0, width, height, 0, glMemory, glFormat, glMemory, null);
  }
  webGL.texParameteri(webGL.TEXTURE_2D, webGL.TEXTURE_WRAP_S, texture2D._wrapS.glCode);
  webGL.texParameteri(webGL.TEXTURE_2D, webGL.TEXTURE_WRAP_T, texture2D._wrapT.glCode);
  webGL.texParameteri(webGL.TEXTURE_2D, webGL.TEXTURE_MAG_FILTER, texture2D._magFilter.glCode);
  webGL.texParameteri(webGL.TEXTURE_2D, webGL.TEXTURE_MIN_FILTER, texture2D._minFilter.glCode);
  webGL.bindTexture(webGL.TEXTURE_2D, null);
  return texture2D;
};

createTexture2D_Image = function(url, param) {
  return imagePromise(url).then(function(image) {
    return new Promise(function(resolve, reject) {
      var texture2D;
      param = param || {};
      texture2D = createTexture2DHelper(true, image, param);
      if (!texture2D) {
        return reject(new Error("Create Texture2D ERR."));
      }
      return resolve(texture2D);
    });
  });
};

createTexture2D_Data = function(data, param) {
  var texture2D;
  texture2D = createTexture2DHelper(true, data, param);
  if (!texture2D) {
    throw new Error("Create Texture2D ERR.");
  }
  return texture2D;
};

createTexture2D_Size = function(width, height, param) {
  var texture2D;
  texture2D = createTexture2DHelper(false, width, height, param);
  if (!texture2D) {
    throw new Error("Create Texture2D ERR.");
  }
  return texture2D;
};

destoryTexture2D = function(texture2D) {
  if (texture2D._hTexture) {
    webGL.deleteTexture(texture2D._hTexture);
  }
  texture2D._hTexture = null;
  texture2D._width = 0;
  texture2D._height = 0;
  texture2D._format = null;
  texture2D._wrapS = null;
  texture2D._wrapT = null;
  texture2D._magFilter = null;
  texture2D._minFilter = null;
  texture2D._mipMap = false;
};

TextureCube = function() {
  this._hTexture = null;
  this._width = 0;
  this._height = 0;
  this._format = null;
  this._wrapS = null;
  this._wrapT = null;
  this._magFilter = null;
  this._minFilter = null;
  this._mipMap = false;
};

createTextureCubeHelper = function(isImageObj) {
  var glFormat, glMemory, height, imageArray, param, ref, textureCube, width;
  if (isImageObj) {
    imageArray = arguments[1];
    param = arguments[2] || {};
  } else {
    width = arguments[1];
    height = arguments[2];
    param = arguments[3] || {};
  }
  textureCube = new TextureCube();
  texture2D._format = param.format || TextureFormat.RGBA;
  texture2D._wrapS = param.wrapS || TextureWrap.EDGE;
  texture2D._wrapT = param.wrapT || TextureWrap.EDGE;
  texture2D._magFilter = param.magFilter || TextureFilter.LINEAR;
  texture2D._minFilter = param.minFilter || TextureFilter.LINEAR;
  textureCube._hTexture = webGL.createTexture();
  if (!texture._hTexture) {
    return reject(new Error("Create textureCube ERR."));
  }
  webGL.bindTexture(webGL.TEXTURE_CUBE_MAP, textureCube._hTexture);
  ref = texture2D._format, glMemory = ref.glMemory, glFormat = ref.glFormat;
  if (isImageObj) {
    webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glMemory, glFormat, glMemory, imageArray[0]);
    webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glMemory, glFormat, glMemory, imageArray[1]);
    webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glMemory, glFormat, glMemory, imageArray[2]);
    webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glMemory, glFormat, glMemory, imageArray[3]);
    webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glMemory, glFormat, glMemory, imageArray[4]);
    webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glMemory, glFormat, glMemory, imageArray[5]);
  } else {
    webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, width, height, 0, glMemory, glFormat, glMemory, null);
    webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, width, height, 0, glMemory, glFormat, glMemory, null);
    webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, width, height, 0, glMemory, glFormat, glMemory, null);
    webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, width, height, 0, glMemory, glFormat, glMemory, null);
    webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, width, height, 0, glMemory, glFormat, glMemory, null);
    webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, width, height, 0, glMemory, glFormat, glMemory, null);
  }
  webGL.texParameteri(webGL.TEXTURE_CUBE_MAP, webGL.TEXTURE_WRAP_S, texture2D._wrapS.glCode);
  webGL.texParameteri(webGL.TEXTURE_CUBE_MAP, webGL.TEXTURE_WRAP_T, texture2D._wrapT.glCode);
  webGL.texParameteri(webGL.TEXTURE_CUBE_MAP, webGL.TEXTURE_MAG_FILTER, texture2D._magFilter.glCode);
  webGL.texParameteri(webGL.TEXTURE_CUBE_MAP, webGL.TEXTURE_MIN_FILTER, texture2D._minFilter.glCode);
  webGL.bindTexture(webGL.TEXTURE_CUBE_MAP, null);
  return textureCube;
};

createTextureCube_Image = function(urlsArray, param) {
  return Promise.all([imagePromise(urlsArray[0]), imagePromise(urlsArray[1]), imagePromise(urlsArray[2]), imagePromise(urlsArray[3]), imagePromise(urlsArray[4]), imagePromise(urlsArray[5])]).then(function(imageArray) {
    return new Promise(function(resolve, reject) {
      var texture2D;
      param = param || {};
      texture2D = createTextureCubeHelper(true, imageArray, param);
      if (!texture2D) {
        return reject(new Error("Create Texture2D ERR."));
      }
      return resolve(texture2D);
    });
  });
};

createTextureCube_Data = function(dataArray, param) {
  var textureCube;
  textureCube = createTextureCubeHelper(true, dataArray, param);
  if (!textureCube) {
    throw new Error("Create Texture2D ERR.");
  }
  return textureCube;
};

createTextureCube_Size = function(width, height, param) {
  var textureCube;
  textureCube = createTextureCubeHelper(false, width, height, param);
  if (!textureCube) {
    throw new Error("Create Texture2D ERR.");
  }
  return textureCube;
};

destoryTextureCube = function() {
  if (textureCube._hTexture) {
    webGL.deleteTexture(textureCube._hTexture);
  }
  textureCube._hTexture = null;
  textureCube._width = 0;
  textureCube._height = 0;
  textureCube._format = null;
  textureCube._wrapS = null;
  textureCube._wrapT = null;
  textureCube._magFilter = null;
  textureCube._minFilter = null;
  textureCube._mipMap = false;
};

glState = {
  clearColorRed: void 0,
  clearColorGreen: void 0,
  clearColorBlue: void 0,
  clearColorAlpha: void 0,
  clearDepth: void 0,
  clearStencil: void 0,
  viewPortOx: void 0,
  viewPortOy: void 0,
  viewPortWidth: void 0,
  viewPortHeight: void 0,
  viewPortNear: void 0,
  viewPortFar: void 0,
  lineWidth: void 0,
  cullEnable: void 0,
  cullFront: void 0,
  cullFace: void 0,
  polygonOffsetEnable: void 0,
  polygonOffsetSlope: void 0,
  polygonOffsetUnit: void 0,
  scissorEnable: void 0,
  scissorOx: void 0,
  scissorOy: void 0,
  scissorWidth: void 0,
  scissorHeight: void 0,
  stencilEnable: void 0,
  stencilFrontWriteMask: void 0,
  stencilFrontReadMask: void 0,
  stencilFrontRefValue: void 0,
  stencilFrontFunc: void 0,
  stencilFrontOptFail: void 0,
  stencilFrontOptZFail: void 0,
  stencilFrontOptPass: void 0,
  stencilBackWriteMask: void 0,
  stencilBackReadMask: void 0,
  stencilBackRefValue: void 0,
  stencilBackFunc: void 0,
  stencilBackOptFail: void 0,
  stencilBackOptZFail: void 0,
  stencilBackOptPass: void 0,
  depthEnable: void 0,
  depthMask: void 0,
  depthFunc: void 0,
  blendEnable: void 0,
  blendRefRed: void 0,
  blendRefGreen: void 0,
  blendRefBlue: void 0,
  blendRefAlpha: void 0,
  blendSrcRGBFunc: void 0,
  blendSrcAlphaFunc: void 0,
  blendDstRGBFunc: void 0,
  blendDstAlphaFunc: void 0,
  blendRGBOpt: void 0,
  blendAlphaOpt: void 0,
  colorMaskRed: void 0,
  colorMaskGreen: void 0,
  colorMaskBlue: void 0,
  colorMaskAlpha: void 0,
  ditherEnable: void 0,
  nowFrame: null,
  nowShader: null,
  nowTexture: 0
};

clearFrame = function(param) {
  var clearColorAlpha, clearColorBlue, clearColorGreen, clearColorRed, clearDepth, clearFlag, clearStencil, ref, ref1, ref2, ref3, ref4, ref5, updateFlag;
  clearColorRed = (ref = param.clearColorRed) != null ? ref : 0;
  clearColorGreen = (ref1 = param.clearColorGreen) != null ? ref1 : 0;
  clearColorBlue = (ref2 = param.clearColorBlue) != null ? ref2 : 0;
  clearColorAlpha = (ref3 = param.clearColorAlpha) != null ? ref3 : 0;
  updateFlag = glState.clearColorRed !== param.clearColorRed || glState.clearColorGreen !== param.clearColorGreen || glState.clearColorBlue !== param.clearColorBlue || glState.clearColorAlpha !== param.clearColorAlpha;
  if (updateFlag) {
    glState.clearColorRed = param.clearColorRed;
    glState.clearColorGreen = param.clearColorGreen;
    glState.clearColorBlue = param.clearColorBlue;
    glState.clearColorAlpha = param.clearColorAlpha;
    webGL.clearColor(glState.clearColorRed, glState.clearColorGreen, glState.clearColorBlue, glState.clearColorAlpha);
  }
  clearDepth = (ref4 = param.clearDepth) != null ? ref4 : 1.0;
  if (glState.clearDepth !== clearDepth) {
    glState.clearDepth = clearDepth;
    webGL.clearDepth(clearDepth);
  }
  clearStencil = (ref5 = param.clearStencil) != null ? ref5 : 0x00000000;
  if (glState.clearStencil !== clearStencil) {
    glState.clearStencil = clearStencil;
    webGL.clearStencil(clearStencil);
  }
  clearFlag = 0;
  updateFlag = "number" === typeof param.clearColorRed || "number" === typeof param.clearColorGreen || "number" === typeof param.clearColorBlue || "number" === typeof param.clearColorAlpha;
  if (updateFlag) {
    clearFlag |= webGL.COLOR_BUFFER_BIT;
  }
  if ("number" === typeof param.clearDepth) {
    clearFlag |= webGL.DEPTH_BUFFER_BIT;
  }
  if ("number" === typeof param.clearStencil) {
    clearFlag |= webGL.STENCIL_BUFFER_BIT;
  }
  webGL.clear(clearFlag);
};

bindAttributeBuffer = function(name, size, stride, offset, data) {
  var varInfo;
  varInfo = glState.nowShader._attributeMap[name];
  if (!varInfo) {
    console.error("Attribute not found <" + name + ">.");
    return;
  }
  webGL.enableVertexAttribArray(varInfo.location);
  webGL.bindBuffer(webGL.ARRAY_BUFFER, data._hVertex);
  webGL.vertexAttribPointer(varInfo.location, size, varInfo.typeInfo.typeCode, false, stride * varInfo.typeInfo.unitBytes, offset * varInfo.typeInfo.unitBytes);
  webGL.bindBuffer(webGL.ARRAY_BUFFER, null);
};

bindAttributeConst = function(name, data) {
  var varInfo;
  varInfo = glState.nowShader._attributeMap[name];
  if (!varInfo) {
    console.error("Attribute not found <" + name + ">.");
    return;
  }
  webGL.enableVertexAttribArray(varInfo.location);
  webGL.disableVertexAttribArray(pos);
  switch (varInfo.typeInfo.typeIndex) {
    case 8:
      webGL.vertexAttrib1f(data);
      break;
    case 9:
      webGL.vertexAttrib2fv(data);
      break;
    case 10:
      webGL.vertexAttrib3fv(data);
      break;
    case 11:
      webGL.vertexAttrib4fv(data);
      break;
    default:
      console.error("Unknow attribute type.");
  }
  webGL.bindBuffer(webGL.ARRAY_BUFFER, null);
};

bindUniform = function(name, data) {
  var nowTexture, varInfo;
  varInfo = glState.nowShader._uniformMap[name];
  if (!varInfo) {
    console.error("Uniform not found <" + name + ">.");
    return;
  }
  switch (varInfo.typeInfo.typeIndex) {
    case 0:
      if (1 === varInfo.arraySize) {
        webGL.uniform1i(varInfo.location, data);
      } else {
        webGL.uniform1iv(varInfo.location, data);
      }
      break;
    case 1:
      webGL.uniform2iv(varInfo.location, data);
      break;
    case 2:
      webGL.uniform3iv(varInfo.location, data);
      break;
    case 3:
      webGL.uniform4iv(varInfo.location, data);
      break;
    case 4:
      if (1 === varInfo.arraySize) {
        webGL.uniform1i(varInfo.location, data);
      } else {
        webGL.uniform1iv(varInfo.location, data);
      }
      break;
    case 5:
      webGL.uniform2iv(varInfo.location, data);
      break;
    case 6:
      webGL.uniform3iv(varInfo.location, data);
      break;
    case 7:
      webGL.uniform4iv(varInfo.location, data);
      break;
    case 8:
      if (1 === varInfo.arraySize) {
        webGL.uniform1f(varInfo.location, data);
      } else {
        webGL.uniform1fv(varInfo.location, data);
      }
      break;
    case 9:
      webGL.uniform2fv(varInfo.location, data);
      break;
    case 10:
      webGL.uniform3fv(varInfo.location, data);
      break;
    case 11:
      webGL.uniform4fv(varInfo.location, data);
      break;
    case 12:
      webGL.uniformMatrix2fv(varInfo.location, false, data);
      break;
    case 13:
      webGL.uniformMatrix3fv(varInfo.location, false, data);
      break;
    case 14:
      webGL.uniformMatrix4fv(varInfo.location, false, data);
      break;
    case 15:
      webGL.activeTexture(webGL.TEXTURE0 + nowTexture);
      webGL.bindTexture(webGL.TEXTURE_2D, data._hTexture);
      webGL.uniform1i(varInfo.location, nowTexture);
      nowTexture = nowTexture + 1;
      break;
    case 16:
      webGL.activeTexture(webGL.TEXTURE0 + nowTexture);
      webGL.bindTexture(webGL.TEXTURE_CUBE_MAP, data._hTexture);
      webGL.uniform1i(varInfo.location, nowTexture);
      nowTexture = nowTexture + 1;
      break;
    default:
      console.error("Unknow uniform type.");
  }
};

drawCall = function(param) {
  var attributeArray, cullEnable, cullFace, cullFront, data, depthEnable, depthFunc, depthMask, drawIndex, drawMode, i, idx, j, k, len, len1, lineWidth, name, nowTexture, offset, polygonOffsetEnable, polygonOffsetSlope, polygonOffsetUnit, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref23, ref24, ref25, ref26, ref27, ref28, ref29, ref3, ref30, ref31, ref4, ref5, ref6, ref7, ref8, ref9, shader, size, stencilBackFunc, stencilBackOptFail, stencilBackOptPass, stencilBackOptZFail, stencilBackReadMask, stencilBackRefValue, stencilBackWriteMask, stencilEnable, stencilFrontFunc, stencilFrontOpFail, stencilFrontOpPass, stencilFrontOpZFail, stencilFrontReadMask, stencilFrontRefValue, stencilFrontWriteMask, stride, uniformArray, updateFlag, viewPortFar, viewPortHeight, viewPortNear, viewPortOx, viewPortOy, viewPortWidth;
  viewPortOx = (ref = param.viewPortOx) != null ? ref : 0;
  viewPortOy = (ref1 = param.viewPortOy) != null ? ref1 : 0;
  viewPortWidth = (ref2 = param.viewPortWidth) != null ? ref2 : webGL.drawingBufferWidth;
  viewPortHeight = (ref3 = param.viewPortHeight) != null ? ref3 : webGL.drawingBufferHeight;
  updateFlag = glState.viewPortOx !== viewPortOx || glState.viewPortOy !== viewPortOy || glState.viewPortWidth !== viewPortWidth || glState.viewPortHeight !== viewPortHeight;
  if (updateFlag) {
    glState.viewPortOx = viewPortOx;
    glState.viewPortOy = viewPortOy;
    glState.viewPortWidth = viewPortWidth;
    glState.viewPortHeight = viewPortHeight;
    webGL.viewport(glState.viewPortOx, glState.viewPortOy, glState.viewPortWidth, glState.viewPortHeight);
  }
  viewPortNear = (ref4 = param.viewPortNear) != null ? ref4 : -1;
  viewPortFar = (ref5 = param.viewPortFar) != null ? ref5 : 1;
  updateFlag = glState.viewPortNear !== viewPortNear || glState.viewPortFar !== viewPortFar;
  if (updateFlag) {
    glState.viewPortNear = viewPortNear;
    glState.viewPortFar = viewPortFar;
    webGL.depthRange(glState.viewPortNear, glState.viewPortFar);
  }
  lineWidth = (ref6 = param.lineWidth) != null ? ref6 : 1;
  if (glState.lineWidth !== lineWidth) {
    glState.lineWidth = lineWidth;
    webGL.lineWidth(glState.lineWidth);
  }
  cullEnable = (ref7 = param.cullEnable) != null ? ref7 : true;
  if (glState.cullEnable !== cullEnable) {
    glState.cullEnable = cullEnable;
    if (glState.cullEnable) {
      webGL.enable(webGL.CULL_FACE);
    } else {
      webGL.disable(webGL.CULL_FACE);
    }
  }
  cullFront = (ref8 = param.cullFront) != null ? ref8 : webGL.CCW;
  if (glState.cullFront !== cullFront) {
    glState.cullFront = cullFront;
    webGL.frontFace(glState.cullFront);
  }
  cullFace = (ref9 = param.cullFace) != null ? ref9 : webGL.BACK;
  if (glState.cullFace !== cullFace) {
    glState.cullFace = cullFace;
    webGL.cullFace(glState.cullFace);
  }
  polygonOffsetEnable = (ref10 = glState.polygonOffsetEnable) != null ? ref10 : false;
  if (glState.polygonOffsetEnable !== polygonOffsetEnable) {
    glState.polygonOffsetEnable = polygonOffsetEnable;
    if (glState.polygonOffsetEnable) {
      webGL.enable(webGL.POLYGON_OFFSET_FILL);
    } else {
      webGL.disable(webGL.POLYGON_OFFSET_FILL);
    }
  }
  polygonOffsetSlope = (ref11 = glState.polygonOffsetSlope) != null ? ref11 : 0;
  polygonOffsetUnit = (ref12 = glState.polygonOffsetUnit) != null ? ref12 : 0;
  updateFlag = glState.polygonOffsetSlope !== polygonOffsetSlope || glState.polygonOffsetUnit !== polygonOffsetUnit;
  if (updateFlag) {
    glState.polygonOffsetSlope = polygonOffsetSlope;
    glState.polygonOffsetUnit = polygonOffsetUnit;
    webGL.polygonOffset(glState.polygonOffsetSlope, glState.polygonOffsetUnit);
  }

  /*
  scissorEnable = glState.scissorEnable ? false
  if glState.scissorEnable != scissorEnable
    glState.scissorEnable = scissorEnable
    if glState.scissorEnable
      webGL.enable(webGL.SCISSOR_TEST)
    else
      webGL.disable(webGL.SCISSOR_TEST)
  
  scissorOx = param.scissorOx ? 0
  scissorOy = param.scissorOy ? 0
  scissorWidth = param.scissorWidth ? 0
  scissorHeight = param.scissorHeight ? 0
  updateFlag =
    glState.scissorOx != scissorOx or
    glState.scissorOy != scissorOy or
    glState.scissorWidth != scissorWidth or
    glState.scissorHeight != scissorHeight
  if updateFlag
    glState.scissorOx = scissorOx
    glState.scissorOy = scissorOy
    glState.scissorWidth = scissorWidth
    glState.scissorHeight = scissorHeight
    webGL.scissor(glState.scissorOx, glState.scissorOy, glState.scissorWidth, glState.scissorHeight)
   */
  stencilEnable = (ref13 = glState.stencilEnable) != null ? ref13 : false;
  if (glState.stencilEnable !== stencilEnable) {
    glState.stencilEnable = stencilEnable;
    if (glState.stencilEnable) {
      webGL.enable(webGL.STENCIL_TEST);
    } else {
      webGL.disable(webGL.STENCIL_TEST);
    }
  }
  stencilFrontWriteMask = (ref14 = param.stencilFrontWriteMask) != null ? ref14 : 0xFFFFFFFF;
  if (glState.stencilMaskSeparate !== stencilFrontWriteMask) {
    glState.stencilMaskSeparate = stencilFrontWriteMask;
    webGL.stencilMaskSeparate(webGL.FRONT, glState.stencilMaskSeparate);
  }
  stencilFrontReadMask = (ref15 = glState.stencilFrontReadMask) != null ? ref15 : 0xFFFFFFFF;
  stencilFrontRefValue = (ref16 = glState.stencilFrontRefValue) != null ? ref16 : 0;
  stencilFrontFunc = glState.stencilFrontFunc || webGL.EQUAL;
  updateFlag = glState.stencilFrontReadMask !== stencilFrontReadMask || glState.stencilFrontRefValue !== stencilFrontRefValue || glState.stencilFrontFunc !== stencilFrontFunc;
  if (updateFlag) {
    glState.stencilFrontReadMask = stencilFrontReadMask;
    glState.stencilFrontRefValue = stencilFrontRefValue;
    glState.stencilFrontFunc = stencilFrontFunc;
    webGL.stencilFuncSeparate(webGL.FRONT, glState.stencilFrontFunc, glState.stencilFrontRefValue, glState.stencilFrontReadMask);
  }
  stencilFrontOpFail = (ref17 = glState.stencilFrontOpFail) != null ? ref17 : webGL.KEEP;
  stencilFrontOpZFail = (ref18 = glState.stencilFrontOpZFail) != null ? ref18 : webGL.KEEP;
  stencilFrontOpPass = (ref19 = glState.stencilFrontOpPass) != null ? ref19 : webGL.KEEP;
  updateFlag = glState.stencilFrontOpFail !== stencilFrontOpFail || glState.stencilFrontOpZFail !== stencilFrontOpZFail || glState.stencilFrontOpPass !== stencilFrontOpPass;
  if (updateFlag) {
    glState.stencilFrontOpFail = stencilFrontOpFail;
    glState.stencilFrontOpZFail = stencilFrontOpZFail;
    glState.stencilFrontOpPass = stencilFrontOpPass;
    webGL.stencilOpSeparate(webGL.FRONT, glState.stencilFrontOpFail, glState.stencilFrontOpZFail, glState.stencilFrontOpPass);
  }
  stencilBackWriteMask = (ref20 = param.stencilBackWriteMask) != null ? ref20 : 0xFFFFFFFF;
  if (glState.stencilMaskSeparate !== stencilBackWriteMask) {
    glState.stencilMaskSeparate = stencilBackWriteMask;
    webGL.stencilMaskSeparate(webGL.BACK, glState.stencilMaskSeparate);
  }
  stencilBackReadMask = (ref21 = glState.stencilBackReadMask) != null ? ref21 : 0xFFFFFFFF;
  stencilBackRefValue = (ref22 = glState.stencilBackRefValue) != null ? ref22 : 0;
  stencilBackFunc = glState.stencilBackFunc || webGL.EQUAL;
  updateFlag = glState.stencilBackReadMask !== stencilBackReadMask || glState.stencilBackRefValue !== stencilBackRefValue || glState.stencilBackFunc !== stencilBackFunc;
  if (updateFlag) {
    glState.stencilBackReadMask = stencilBackReadMask;
    glState.stencilBackRefValue = stencilBackRefValue;
    glState.stencilBackFunc = stencilBackFunc;
    webGL.stencilFuncSeparate(webGL.BACK, glState.stencilBackFunc, glState.stencilBackRefValue, glState.stencilBackReadMask);
  }
  stencilBackOptFail = (ref23 = glState.stencilBackOptFail) != null ? ref23 : webGL.KEEP;
  stencilBackOptZFail = (ref24 = glState.stencilBackOptZFail) != null ? ref24 : webGL.KEEP;
  stencilBackOptPass = (ref25 = glState.stencilBackOptPass) != null ? ref25 : webGL.KEEP;
  updateFlag = glState.stencilBackOptFail !== stencilBackOptFail || glState.stencilBackOptZFail !== stencilBackOptZFail || glState.stencilBackOptPass !== stencilBackOptPass;
  if (updateFlag) {
    glState.stencilBackOptFail = stencilBackOptFail;
    glState.stencilBackOptZFail = stencilBackOptZFail;
    glState.stencilBackOptPass = stencilBackOptPass;
    webGL.stencilOpSeparate(webGL.BACK, glState.stencilBackOptFail, glState.stencilBackOptZFail, glState.stencilBackOptPass);
  }
  depthEnable = (ref26 = glState.depthEnable) != null ? ref26 : true;
  if (glState.depthEnable !== depthEnable) {
    glState.depthEnable = depthEnable;
    if (glState.depthEnable) {
      webGL.enable(webGL.DEPTH_TEST);
    } else {
      webGL.disable(webGL.DEPTH_TEST);
    }
  }
  depthMask = (ref27 = glState.depthMask) != null ? ref27 : true;
  if (glState.depthMask !== depthMask) {
    glState.depthMask = depthMask;
    webGL.depthMask(glState.depthMask);
  }
  depthFunc = (ref28 = glState.depthFunc) != null ? ref28 : webGL.LESS;
  if (glState.depthFunc !== depthFunc) {
    glState.depthFunc = depthFunc;
    webGL.depthFunc(glState.depthFunc);
  }

  /*
  blendEnable = glState.blendEnable ? false
  if glState.blendEnable != blendEnable
    glState.blendEnable = blendEnable
    if glState.blendEnable
      webGL.enable(webGL.BLEND)
    else
      webGL.disable(webGL.BLEND)
  
  blendRefRed = glState.blendRefRed ? 0
  blendRefGreen = glState.blendRefGreen ? 0
  blendRefBlue = glState.blendRefBlue ? 0
  blendRefAlpha = glState.blendRefAlpha ? 0
  updateFlag =
    glState.blendRefRed != blendRefRed or
    glState.blendRefGreen != blendRefGreen or
    glState.blendRefBlue != blendRefBlue or
    glState.blendRefAlpha != blendRefAlpha
  if updateFlag
    glState.blendRefRed = blendRefRed
    glState.blendRefGreen = blendRefGreen
    glState.blendRefBlue = blendRefBlue
    glState.blendRefAlpha = blendRefAlpha
    webGL.blendColor(glState.blendRefRed, glState.blendRefGreen, glState.blendRefBlue, glState.blendRefAlpha)
  
  blendSrcRGBFunc = glState.blendSrcRGBFunc ? webGL.SRC_ALPHA
  blendSrcAlphaFunc = glState.blendSrcAlphaFunc ? webGL.SRC_ALPHA
  blendDstRGBFunc = glState.blendDstRGBFunc ? webGL.ONE_MINUS_SRC_ALPHA
  blendDstAlphaFunc = glState.blendDstAlphaFunc ? webGL.ONE_MINUS_SRC_ALPHA
  updateFlag =
    glState.blendSrcRGBFunc != blendSrcRGBFunc or
    glState.blendSrcAlphaFunc != blendSrcAlphaFunc or
    glState.blendDstRGBFunc != blendDstRGBFunc or
    glState.blendDstAlphaFunc != blendDstAlphaFunc
  if updateFlag
    glState.blendSrcRGBFunc = blendSrcRGBFunc
    glState.blendSrcAlphaFunc = blendSrcAlphaFunc
    glState.blendDstRGBFunc = blendDstRGBFunc
    glState.blendDstAlphaFunc = blendDstAlphaFunc
    webGL.blendFuncSeparate(glState.blendSrcRGBFunc, glState.blendSrcAlphaFunc, glState.blendDstRGBFunc, glState.blendDstAlphaFunc)
  
  blendRGBOpt = glState.blendRGBOpt ? webGL.FUNC_ADD
  blendAlphaOpt = glState.blendAlphaOpt ? webGL.FUNC_ADD
  updateFlag =
    glState.blendRGBOpt != blendRGBOpt or
    glState.blendAlphaOpt != blendAlphaOpt
  if updateFlag
    glState.blendRGBOpt = blendRGBOpt
    glState.blendAlphaOpt = blendAlphaOpt
    webGL.blendEquationSeparate(glState.blendRGBOpt, glState.blendAlphaOpt)
  
  colorMaskRed = glState.colorMaskRed ? true
  colorMaskGreen = glState.colorMaskGreen ? true
  colorMaskBlue = glState.colorMaskBlue ? true
  colorMaskAlpha = glState.colorMaskAlpha ? true
  updateFlag =
    glState.colorMaskRed != colorMaskRed or
    glState.colorMaskGreen != colorMaskGreen or
    glState.colorMaskBlue != colorMaskBlue or
    glState.colorMaskAlpha != colorMaskAlpha
  if updateFlag
    glState.colorMaskRed = colorMaskRed
    glState.colorMaskGreen = colorMaskGreen
    glState.colorMaskBlue = colorMaskBlue
    glState.colorMaskAlpha = colorMaskAlpha
    webGL.colorMask(glState.colorMaskRed, glState.colorMaskGreen, glState.colorMaskBlue, glState.colorMaskAlpha)
  
  ditherEnable = glState.ditherEnable ? false
  if glState.ditherEnable != ditherEnable
    glState.ditherEnable = ditherEnable
    if glState.ditherEnable
      webGL.enable(webGL.DITHER)
    else
      webGL.disable(webGL.DITHER)
   */
  shader = param.shader;
  if (!shader) {
    throw new Error("drawCall() Need a shader.");
  }
  webGL.useProgram(shader._hShader);
  glState.nowShader = shader;
  uniformArray = param.uniformArray;
  if (!uniformArray) {
    throw new Error("drawCall() Need a uniformArray.");
  }
  for (i = 0, len = uniformArray.length; i < len; i++) {
    ref29 = uniformArray[i], name = ref29.name, data = ref29.data;
    bindUniform(name, data);
  }
  attributeArray = param.attributeArray;
  if (!attributeArray) {
    throw new Error("drawCall() Need a attributeArray.");
  }
  for (j = 0, len1 = attributeArray.length; j < len1; j++) {
    ref30 = attributeArray[j], name = ref30.name, size = ref30.size, stride = ref30.stride, offset = ref30.offset, data = ref30.data;
    bindAttributeBuffer(name, size, stride, offset, data);
  }
  drawIndex = param.drawIndex, drawMode = param.drawMode;
  if (!drawIndex) {
    webGL.drawArrays(drawMode.glCode, 0, param.drawCount);
  } else {
    webGL.bindBuffer(webGL.ELEMENT_ARRAY_BUFFER, drawIndex._hIndex);
    webGL.drawElements(drawMode.glCode, param.drawCount, webGL.UNSIGNED_SHORT, 0);
    webGL.bindBuffer(webGL.ELEMENT_ARRAY_BUFFER, null);
  }
  for (idx = k = 0, ref31 = nowTexture; k < ref31; idx = k += 1) {
    webGL.activeTexture(webGL.TEXTURE0 + idx);
    webGL.bindTexture(webGL.TEXTURE_2D, null);
    webGL.bindTexture(webGL.TEXTURE_CUBE_MAP, null);
  }
  nowTexture = 0;
  webGL.useProgram(null);
};

return {
  webGL: webGL,
  TextureFormat: TextureFormat,
  TextureWrap: TextureWrap,
  TextureFilter: TextureFilter,
  SurfaceFormat: SurfaceFormat,
  BufferUsage: BufferUsage,
  IndexType: IndexType,
  DrawMode: DrawMode,
  createShader: createShader,
  destoryShader: destoryShader,
  createBufferVtx_Array: createBufferVtx_Array,
  createBufferVtx_Size: createBufferVtx_Size,
  destoryBufferVtx: destoryBufferVtx,
  createBufferIdx_Array: createBufferIdx_Array,
  createBufferIdx_Size: createBufferIdx_Size,
  destoryBufferIdx: destoryBufferIdx,
  createBufferMesh_Obj: createBufferMesh_Obj,
  destoryBufferMesh: destoryBufferMesh,
  createTexture2D_Image: createTexture2D_Image,
  createTexture2D_Data: createTexture2D_Data,
  createTexture2D_Size: createTexture2D_Size,
  destoryTexture2D: destoryTexture2D,
  createTextureCube_Image: createTextureCube_Image,
  createTextureCube_Size: createTextureCube_Size,
  destoryTextureCube: destoryTextureCube,
  clearFrame: clearFrame,
  drawCall: drawCall
};
};
