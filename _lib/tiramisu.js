// Generated by CoffeeScript 1.11.1
(function() {
  var BufferUsage, DrawMode, DynamicIndex, DynamicVertex, GLSLType, GLSLVar, IndexType, SHADER_FRAGMENT_LIB, SHADER_PUBLIC_LIB, SHADER_VERTEX_LIB, StaticMesh, StaticShader, StaticTexture2D, StaticTextureCube, SurfaceFormat, TextureFilter, TextureFormat, TextureWrap, bindAttributeBuffer, bindAttributeConst, bindCancelAnime, bindRequestAnime, bindUniform, canvas, canvasArray, createTexture2DHelper, createTextureCubeHelper, decodeObjFile, delayTime, glState, httpGetPromise, httpPostPromise, imagePromise, joinFsCode, joinVsCode, nextTick, onHttpError, onHttpLoad, onHttpTimeout, pramaGL, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, ti, updateAnime, webGL, winCancelAnime, winRequestAnime,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Math.fract = function(num) {
    return num - Math.floor(num);
  };

  Math.clamp = function(num, small, big) {
    if (num < small) {
      return small;
    }
    if (num > big) {
      return big;
    }
    return num;
  };

  Math.saturate = function(num) {
    if (num < 0) {
      return 0;
    }
    if (num > 1) {
      return 1;
    }
    return num;
  };

  Math.lerp = function(step, start, finish) {
    if (step < 0) {
      step = 0;
    } else if (step > 1) {
      step = 1;
    }
    return step * start + (1 - start) * finish;
  };

  Math.$PI = Math.PI;

  Math.$PIx2 = Math.PI * 2;

  Math.$PI_2 = Math.PI / 2;

  Math.$PI_3 = Math.PI / 3;

  Math.$PI_4 = Math.PI / 4;

  Math.$PI_6 = Math.PI / 6;

  Math.$1_PI = 1 / Math.PI;

  Math.$2_PI = 2 / Math.PI;

  Math.$E = Math.E;

  Math.$Ex2 = Math.E * 2;

  Math.$E_2 = Math.E / 2;

  Math.$1_E = 1 / Math.E;

  Math.$SQRT2 = Math.sqrt(2);

  Math.$SQRT3 = Math.sqrt(3);

  Math.$SQRT5 = Math.sqrt(5);

  Math.$SQRT2_2 = Math.sqrt(2) / 2;

  Math.$SQRT3_2 = Math.sqrt(3) / 2;

  Math.$SQRT5_2 = Math.sqrt(5) / 2;

  Math.$SQRT3_3 = Math.sqrt(3) / 3;

  Math.$1_SQRT2 = 1 / Math.sqrt(2);

  Math.$1_SQRT3 = 1 / Math.sqrt(3);

  Math.$1_SQRT5 = 1 / Math.sqrt(5);

  window.m = Math;

  window.ti = ti = {};

  canvasArray = document.getElementsByTagName('canvas');

  if (!canvasArray) {
    throw new Error('Element not dound. <canvas Tiramisu></canvas>');
  }

  canvasArray = Array.prototype.filter.call(canvasArray, function(item) {
    return 'string' === typeof (item.getAttribute('Tiramisu'));
  });

  if (canvasArray.length < 1) {
    throw new Error('Element not dound. <canvas Tiramisu></canvas>');
  } else if (canvasArray.length > 1) {
    throw new Error('More than one elements. <canvas Tiramisu></canvas>');
  }

  canvas = canvasArray[0];

  if (!canvas) {
    return null;
  }

  pramaGL = {
    alpha: (ref = canvas.alpha) != null ? ref : true,
    depth: (ref1 = canvas.depth) != null ? ref1 : true,
    stencil: (ref2 = canvas.stencil) != null ? ref2 : false,
    antialias: (ref3 = canvas.antialias) != null ? ref3 : true,
    premultipliedAlpha: (ref4 = canvas.premultipliedAlpha) != null ? ref4 : true,
    preserveDrawingBuffer: (ref5 = canvas.preserveDrawingBuffer) != null ? ref5 : false
  };

  webGL = canvas.getContext('webgl', pramaGL) || canvas.getContext('experimental-webgl', pramaGL) || canvas.getContext('webkit-3d', pramaGL) || canvas.getContext('moz-webgl', pramaGL) || canvas.getContext('webkit-webgl', pramaGL) || canvas.getContext('ms-webgl', pramaGL) || canvas.getContext('o-webgl', pramaGL);

  if (!webGL) {
    throw new Error("Create webGL context failed.");
  }

  ti.canvas = canvas;

  ti.webGL = webGL;

  TextureFormat = function(name, glFormat, glMemory) {
    this.name = name;
    this.glFormat = glFormat;
    this.glMemory = glMemory;
    Object.freeze(this);
  };

  TextureFormat.prototype.toString = function() {
    return this.name;
  };

  TextureFormat.R4G4B4A4 = new TextureFormat("R4G4B4A4", webGL.RGBA, webGL.UNSIGNED_SHORT_4_4_4_4);

  TextureFormat.R5G5B5A1 = new TextureFormat("R5G5B5A1", webGL.RGBA, webGL.UNSIGNED_SHORT_5_5_5_1);

  TextureFormat.R5G6B5 = new TextureFormat("R5G6B5", webGL.RGB, webGL.UNSIGNED_SHORT_5_6_5);

  TextureFormat.L8 = new TextureFormat("L8", webGL.LUMINANCE, webGL.UNSIGNED_BYTE);

  TextureFormat.A8 = new TextureFormat("A8", webGL.ALPHA, webGL.UNSIGNED_BYTE);

  TextureFormat.L8A8 = new TextureFormat("L8A8", webGL.LUMINANCE_ALPHA, webGL.UNSIGNED_BYTE);

  TextureFormat.R8G8B8 = new TextureFormat("R8G8B8", webGL.RGB, webGL.UNSIGNED_BYTE);

  TextureFormat.R8G8B8A8 = new TextureFormat("R8G8B8A8", webGL.RGBA, webGL.UNSIGNED_BYTE);

  TextureWrap = function(name, glCode) {
    this.name = name;
    this.glCode = glCode;
    Object.freeze(this);
  };

  TextureWrap.prototype.toString = function() {
    return this.name;
  };

  TextureWrap.REPEAT = new TextureWrap("REPEAT", webGL.REPEAT);

  TextureWrap.EDGE = new TextureWrap("EDGE", webGL.CLAMP_TO_EDGE);

  TextureWrap.MIRROR = new TextureWrap("MIRROR", webGL.MIRRORED_REPEAT);

  TextureFilter = function(name, glCode) {
    this.name = name;
    this.glCode = glCode;
    Object.freeze(this);
  };

  TextureFilter.prototype.toString = function() {
    return this.name;
  };

  TextureFilter.NEAREST = new TextureFilter("NEAREST", webGL.NEAREST);

  TextureFilter.LINEAR = new TextureFilter("LINEAR", webGL.LINEAR);

  TextureFilter.NEAREST_NEAREST = new TextureFilter("NEAREST_NEAREST", webGL.NEAREST_MIPMAP_NEARESTA);

  TextureFilter.NEAREST_LINEAR = new TextureFilter("NEAREST_LINEAR", webGL.NEAREST_MIPMAP_LINEAR);

  TextureFilter.LINEAR_NEAREST = new TextureFilter("LINEAR_NEAREST", webGL.LINEAR_MIPMAP_NEAREST);

  TextureFilter.LINEAR_LINEAR = new TextureFilter("LINEAR_LINEAR", webGL.LINEAR_MIPMAP_LINEAR);

  SurfaceFormat = function(name, glCode) {
    this.name = name;
    this.glCode = glCode;
    Object.freeze(this);
  };

  SurfaceFormat.prototype.toString = function() {
    return this.name;
  };

  BufferUsage = function(name, glCode) {
    this.name = name;
    this.glCode = glCode;
    Object.freeze(this);
  };

  BufferUsage.prototype.toString = function() {
    return this.name;
  };

  BufferUsage.STATIC = new BufferUsage("STATIC", webGL.STATIC_DRAW);

  BufferUsage.DYNAMIC = new BufferUsage("DYNAMIC", webGL.DYNAMIC_DRAW);

  BufferUsage.STREAM = new BufferUsage("STREAM", webGL.STREAM_DRAW);

  IndexType = function(name, glCode) {
    this.name = name;
    this.glCode = glCode;
    Object.freeze(this);
  };

  IndexType.prototype.toString = function() {
    return this.name;
  };

  IndexType.BYTE = new IndexType("BYTE", webGL.BYTE);

  IndexType.SHORT = new IndexType("SHORT", webGL.SHORT);

  DrawMode = function(name, glCode) {
    this.name = name;
    this.glCode = glCode;
    Object.freeze(this);
  };

  DrawMode.prototype.toString = function() {
    return this.name;
  };

  DrawMode.POINTS = new DrawMode("POINTS", webGL.POINTS);

  DrawMode.LINE_STRIP = new DrawMode("LINE_STRIP", webGL.LINE_STRIP);

  DrawMode.LINE_LOOP = new DrawMode("LINE_LOOP", webGL.LINE_LOOP);

  DrawMode.LINES = new DrawMode("LINES", webGL.LINES);

  DrawMode.TRIANGLE_STRIP = new DrawMode("TRIANGLE_STRIP", webGL.TRIANGLE_STRIP);

  DrawMode.TRIANGLE_FAN = new DrawMode("TRIANGLE_FAN", webGL.TRIANGLE_FAN);

  DrawMode.TRIANGLES = new DrawMode("TRIANGLES", webGL.TRIANGLES);

  GLSLType = function(typeIndex, typeName, typeCode, unitBytes, unitCount) {
    this.typeIndex = typeIndex;
    this.typeName = typeName;
    this.typeCode = typeCode;
    this.unitBytes = unitBytes;
    this.unitCount = unitCount;
    Object.freeze(this);
  };

  GLSLType.fromGLType = function(webGLType) {
    switch (webGLType) {
      case webGL.BOOL:
        return GLSLType.BOOL;
      case webGL.BOOL_VEC2:
        return GLSLType.BVEC2;
      case webGL.BOOL_VEC3:
        return GLSLType.BVEC3;
      case webGL.BOOL_VEC4:
        return GLSLType.BVEC4;
      case webGL.INT:
        return GLSLType.INT;
      case webGL.INT_VEC2:
        return GLSLType.IVEC2;
      case webGL.INT_VEC3:
        return GLSLType.IVEC3;
      case webGL.INT_VEC4:
        return GLSLType.IVEC4;
      case webGL.FLOAT:
        return GLSLType.FLOAT;
      case webGL.FLOAT_VEC2:
        return GLSLType.VEC2;
      case webGL.FLOAT_VEC3:
        return GLSLType.VEC3;
      case webGL.FLOAT_VEC4:
        return GLSLType.VEC4;
      case webGL.FLOAT_MAT2:
        return GLSLType.MAT2;
      case webGL.FLOAT_MAT3:
        return GLSLType.MAT3;
      case webGL.FLOAT_MAT4:
        return GLSLType.MAT4;
      case webGL.SAMPLER_2D:
        return GLSLType.SAMPLER_2D;
      case webGL.SAMPLER_CUBE:
        return GLSLType.SAMPLER_CUBE;
      default:
        return null;
    }
  };

  GLSLType.BOOL = new GLSLType(0, "bool", webGL.BOOL, 1, 1);

  GLSLType.BVEC2 = new GLSLType(1, "bvec2", webGL.BOOL, 1, 2);

  GLSLType.BVEC3 = new GLSLType(2, "bvec3", webGL.BOOL, 1, 3);

  GLSLType.BVEC4 = new GLSLType(3, "bvec4", webGL.BOOL, 1, 4);

  GLSLType.INT = new GLSLType(4, "int", webGL.INT, 4, 1);

  GLSLType.IVEC2 = new GLSLType(5, "ivec2", webGL.INT, 4, 2);

  GLSLType.IVEC3 = new GLSLType(6, "ivec3", webGL.INT, 4, 3);

  GLSLType.IVEC4 = new GLSLType(7, "ivec4", webGL.INT, 4, 4);

  GLSLType.FLOAT = new GLSLType(8, "float", webGL.FLOAT, 4, 1);

  GLSLType.VEC2 = new GLSLType(9, "vec2", webGL.FLOAT, 4, 2);

  GLSLType.VEC3 = new GLSLType(10, "vec3", webGL.FLOAT, 4, 3);

  GLSLType.VEC4 = new GLSLType(11, "vec4", webGL.FLOAT, 4, 4);

  GLSLType.MAT2 = new GLSLType(12, "mat2", webGL.FLOAT, 4, 4);

  GLSLType.MAT3 = new GLSLType(13, "mat3", webGL.FLOAT, 4, 9);

  GLSLType.MAT4 = new GLSLType(14, "mat4", webGL.FLOAT, 4, 16);

  GLSLType.SAMPLER_2D = new GLSLType(15, "sampler2d", webGL.SAMPLER_2D, 4, 1);

  GLSLType.SAMPLER_CUBE = new GLSLType(16, "samplerCube", webGL.SAMPLER_CUBE, 4, 1);

  GLSLVar = function(info, location) {
    this.varName = info.name;
    this.location = location;
    this.typeInfo = GLSLType.fromGLType(info.type);
    this.arraySize = info.size;
  };

  GLSLVar.prototype.toString = function() {
    return this.typeInfo + " " + this.varName;
  };

  ti.TextureFormat = TextureFormat;

  ti.TextureWrap = TextureWrap;

  ti.TextureFilter = TextureFilter;

  ti.SurfaceFormat = SurfaceFormat;

  ti.BufferUsage = BufferUsage;

  ti.IndexType = IndexType;

  ti.DrawMode = DrawMode;

  ti.GLSLType = GLSLType;

  ti.GLSLVar = GLSLVar;

  nextTick = function(func) {
    if ('function' === typeof func) {
      setTimeout(0, func);
    }
  };

  delayTime = function(millisecond, func) {
    if ('function' === typeof func) {
      setTimeout(millisecond, func);
    }
  };

  winRequestAnime = (ref6 = (ref7 = window.requestAnimationFrame) != null ? ref7 : window.mozRequestAnimationFrame) != null ? ref6 : window.webkitRequestAnimationFrame;

  winCancelAnime = (ref8 = (ref9 = (ref10 = window.cancelAnimationFrame) != null ? ref10 : window.mozCancelAnimationFrame) != null ? ref9 : window.webkitCancelAnimationFrame) != null ? ref8 : window.webkitCancelRequestAnimationFrame;

  if ('function' === typeof winRequestAnime && 'function' === typeof winCancelAnime) {
    bindRequestAnime = winRequestAnime.bind(window);
    bindCancelAnime = winCancelAnime.bind(window);
  } else {
    bindRequestAnime = (function() {
      var lastTime;
      lastTime = 0;
      return function(callback) {
        var callbackWrap, currentTime, timeToCall;
        currentTime = (new Date()).getTime();
        timeToCall = Math.max(0, 16 - (currentTime - lastTime));
        lastTime = currentTime + timeToCall;
        callbackWrap = function() {
          return callback(lastTime * 1000);
        };
        return setTimeout(callbackWrap, timeToCall);
      };
    })();
    bindCancelAnime = function(handle) {
      return clearTimeout(handle) * 1000;
    };
  }

  updateAnime = function(updateFunc) {
    var handle, wrapFunc;
    handle = null;
    wrapFunc = function() {
      updateFunc();
      return handle = bindRequestAnime(wrapFunc);
    };
    handle = bindRequestAnime(wrapFunc);
    return function() {
      return bindCancelAnime(handle);
    };
  };

  imagePromise = function(url) {
    return new Promise(function(resolve, reject) {
      var image;
      image = new Image();
      image.onload = function() {
        return resolve(image);
      };
      image.onerror = function() {
        return reject(new Error("Load Image ERR. <" + url + ">"));
      };
      return image.src = url;
    });
  };

  onHttpLoad = function(xhr, resolve, reject) {
    return function() {
      var error;
      if (xhr.response) {
        return resolve(xhr.response);
      } else if ('json' === xhr.responseType) {
        try {
          return resolve(JSON.parse(xhr.responseText));
        } catch (error1) {
          error = error1;
          return reject(error);
        }
      } else {
        return reject(new Error("Unkonw response type."));
      }
    };
  };

  onHttpError = function(resolve, reject) {
    return function() {
      return reject(new Error("HTTP " + xhr.status + "."));
    };
  };

  onHttpTimeout = function(resolve, reject) {
    return function() {
      return reject(new Error("HTTP time out."));
    };
  };

  httpGetPromise = function(url, header, resType, timeout) {
    timeout = timeout != null ? timeout : 5000;
    resType = resType != null ? resType : 'text';
    return new Promise(function(resolve, reject) {
      var key, val, xhr;
      xhr = new XMLHttpRequest();
      xhr.onload = onHttpLoad(xhr, resolve, reject);
      xhr.onerror = onHttpError(resolve, reject);
      xhr.ontimeout = onHttpTimeout(resolve, reject);
      if (header) {
        for (key in header) {
          val = header[key];
          xhe.setRequestHeader(key, val);
        }
      }
      xhr.responseType = resType;
      xhr.timeout = timeout;
      xhr.open("GET", url);
      return xhr.send(null);
    });
  };

  httpPostPromise = function(url, header, body, resType, timeout) {
    timeout = timeout != null ? timeout : 5000;
    resType = resType != null ? resType : 'text';
    return new Promise(function(resolve, reject) {
      var key, val, xhr;
      xhr = new XMLHttpRequest();
      xhr.onload = onHttpLoad(resolve, reject);
      xhr.onerror = onHttpError(resolve, reject);
      xhr.ontimeout = onHttpTimeout(resolve, reject);
      if (header) {
        for (key in header) {
          val = header[key];
          xhe.setRequestHeader(key, val);
        }
      }
      xhr.responseType = resType;
      xhr.timeout = timeout;
      xhr.open("POST", url);
      return xhr.send(body);
    });
  };

  ti.nextTick = nextTick;

  ti.delayTime = delayTime;

  ti.updateAnime = updateAnime;

  SHADER_PUBLIC_LIB = 'const float C_0 = 0.0;\nconst float C_1 = 1.0;\nconst float C_PI = 3.141592653589793;\nconst float C_2xPI = 2.0 * C_PI;\nconst float C_1_PI = 1.0 / C_PI;\nconst float C_EPSILON = 1e-6;\n\nfloat saturate(const in float a) { return clamp(a, C_0, C_1); }\nvec2 saturate(const in vec2 a) { return clamp(a, C_0, C_1); }\nvec3 saturate(const in vec3 a) { return clamp(a, C_0, C_1); }\nvec4 saturate(const in vec4 a) { return clamp(a, C_0, C_1); }\n\nfloat pow2(const in float a) { return a * a; }\nfloat pow3(const in float a) { return a * a * a; }\nfloat pow4(const in float a) { float b = a * a; return b * b; }';

  SHADER_VERTEX_LIB = '';

  SHADER_FRAGMENT_LIB = 'const float GAMMA_IN = 2.2;\nvec3 gammaIn(const in vec3 c) { return pow(c, vec3(GAMMA_IN)); }\nvec4 gammaIn(const in vec4 c) { return pow(c, vec4(GAMMA_IN)); }\nconst float GAMMA_OUT = 1.0 / GAMMA_IN;\nvec3 gammaOut(const in vec3 c) { return pow(c, vec3(GAMMA_OUT)); }\nvec4 gammaOut(const in vec4 c) { return pow(c, vec4(GAMMA_OUT)); }';

  joinVsCode = function(vsCode) {
    return "//////////////// SHADER_PUBLIC_LIB ////////////////\n" + SHADER_PUBLIC_LIB + "\n\n//////////////// SHADER_VERTEX_LIB ////////////////\n" + SHADER_VERTEX_LIB + "\n\n//////////////// User VS Code ////////////////\n" + vsCode;
  };

  joinFsCode = function(fsCode) {
    return "precision mediump float;\n\n//////////////// SHADER_PUBLIC_LIB ////////////////\n" + SHADER_PUBLIC_LIB + "\n\n//////////////// SHADER_FRAGMENT_LIB ////////////////\n" + SHADER_VERTEX_LIB + "\n\n//////////////// User FS Code ////////////////\n" + fsCode;
  };

  StaticShader = (function() {
    function StaticShader() {
      this._hShader = null;
      this._uniformNum = 0;
      this._uniformMap = Object.create(null);
      this._attributeNum = 0;
      this._attributeMap = Object.create(null);
      return;
    }

    StaticShader.prototype.getUniformNum = function() {
      return this._uniformNum;
    };

    StaticShader.prototype.getUniformName = function(name) {
      return this._uniformMap[name];
    };

    StaticShader.prototype.getAttributeNum = function() {
      return this._attributeNum;
    };

    StaticShader.prototype.getAttributeName = function(name) {
      return this._attributeMap[name];
    };

    return StaticShader;

  })();

  StaticShader.create_VsFs = function(vsCode, fsCode) {
    return new Promise(function(resolve, reject) {
      var hFragment, hShader, hVertex, i, idx, info, infoLog, isOk, j, location, realFsCode, realVsCode, ref11, ref12, shader;
      isOk = false;
      while (true) {
        hVertex = webGL.createShader(webGL.VERTEX_SHADER);
        if (!hVertex) {
          console.error("Create shader ERR.");
          break;
        }
        realVsCode = joinVsCode(vsCode);
        webGL.shaderSource(hVertex, realVsCode);
        webGL.compileShader(hVertex);
        if (!webGL.getShaderParameter(hVertex, webGL.COMPILE_STATUS)) {
          infoLog = webGL.getShaderInfoLog(hVertex);
          console.error("Vertex StaticShader ERR." + infoLog);
          break;
        }
        hFragment = webGL.createShader(webGL.FRAGMENT_SHADER);
        if (!hFragment) {
          console.error("Create shader ERR.");
          break;
        }
        realFsCode = joinFsCode(fsCode);
        webGL.shaderSource(hFragment, realFsCode);
        webGL.compileShader(hFragment);
        if (!webGL.getShaderParameter(hFragment, webGL.COMPILE_STATUS)) {
          infoLog = webGL.getShaderInfoLog(hFragment);
          console.error("Fragment StaticShader ERR." + infoLog);
          break;
        }
        hShader = webGL.createProgram();
        if (!hShader) {
          console.error("Create Program ERR.");
          break;
        }
        webGL.attachShader(hShader, hVertex);
        webGL.attachShader(hShader, hFragment);
        webGL.linkProgram(hShader);
        if (!webGL.getProgramParameter(hShader, webGL.LINK_STATUS)) {
          infoLog = webGL.getProgramInfoLog(hShader);
          console.error("StaticShader Link ERR.\n" + infoLog);
          break;
        }
        isOk = true;
        break;
      }
      if (hVertex) {
        webGL.deleteShader(hVertex);
      }
      if (hFragment) {
        webGL.deleteShader(hFragment);
      }
      if (!isOk) {
        if (hShader) {
          webGL.deleteProgram(hShader);
        }
        return reject(new Error("createShader() ERR."));
      }
      shader = new StaticShader();
      shader._hShader = hShader;
      shader._uniformNum = webGL.getProgramParameter(hShader, webGL.ACTIVE_UNIFORMS);
      for (idx = i = 0, ref11 = shader._uniformNum; i < ref11; idx = i += 1) {
        info = webGL.getActiveUniform(hShader, idx);
        location = webGL.getUniformLocation(hShader, info.name);
        shader._uniformMap[info.name] = new GLSLVar(info, location);
      }
      shader._attributeNum = webGL.getProgramParameter(hShader, webGL.ACTIVE_ATTRIBUTES);
      for (idx = j = 0, ref12 = shader._attributeNum; j < ref12; idx = j += 1) {
        info = webGL.getActiveAttrib(hShader, idx);
        location = webGL.getAttribLocation(hShader, info.name);
        shader._attributeMap[info.name] = new GLSLVar(info, location);
      }
      return resolve(shader);
    });
  };

  StaticShader.destory = function(shader) {
    if (shader._hShader) {
      webGL.deleteProgram(shader._hShader);
    }
    shader._hShader = null;
    shader._uniformNum = 0;
    shader._uniformMap = null;
    shader._attributeNum = 0;
    shader._attributeMap = null;
  };

  ti.StaticShader = StaticShader;

  StaticTexture2D = (function() {
    function StaticTexture2D() {
      this._hTexture = null;
      this._width = 0;
      this._height = 0;
      this._format = null;
      this._wrapS = null;
      this._wrapT = null;
      this._magFilter = null;
      this._minFilter = null;
      this._mipMap = false;
      return;
    }

    return StaticTexture2D;

  })();

  createTexture2DHelper = function(isImageObj) {
    var glFormat, glMemory, height, image, param, ref11, ref12, ref13, ref14, ref15, ref16, texture2D, width;
    if (isImageObj) {
      image = arguments[1];
      param = arguments[2] || {};
    } else {
      width = arguments[1];
      height = arguments[2];
      param = arguments[3] || {};
    }
    texture2D = new StaticTexture2D();
    texture2D._format = (ref11 = param.format) != null ? ref11 : TextureFormat.R8G8B8A8;
    texture2D._wrapS = (ref12 = param.wrapS) != null ? ref12 : TextureWrap.EDGE;
    texture2D._wrapT = (ref13 = param.wrapT) != null ? ref13 : TextureWrap.EDGE;
    texture2D._magFilter = (ref14 = param.magFilter) != null ? ref14 : TextureFilter.LINEAR;
    texture2D._minFilter = (ref15 = param.minFilter) != null ? ref15 : TextureFilter.LINEAR;
    texture2D._hTexture = webGL.createTexture();
    if (!texture._hTexture) {
      return null;
    }
    webGL.bindTexture(webGL.TEXTURE_2D, texture2D._hTexture);
    ref16 = texture2D._format, glMemory = ref16.glMemory, glFormat = ref16.glFormat;
    if (isImageObj) {
      webGL.texImage2D(webGL.TEXTURE_2D, 0, glFormat, glFormat, glMemory, image);
    } else {
      webGL.texImage2D(webGL.TEXTURE_2D, 0, width, height, 0, glFormat, glFormat, glMemory, null);
    }
    webGL.texParameteri(webGL.TEXTURE_2D, webGL.TEXTURE_WRAP_S, texture2D._wrapS.glCode);
    webGL.texParameteri(webGL.TEXTURE_2D, webGL.TEXTURE_WRAP_T, texture2D._wrapT.glCode);
    webGL.texParameteri(webGL.TEXTURE_2D, webGL.TEXTURE_MAG_FILTER, texture2D._magFilter.glCode);
    webGL.texParameteri(webGL.TEXTURE_2D, webGL.TEXTURE_MIN_FILTER, texture2D._minFilter.glCode);
    webGL.bindTexture(webGL.TEXTURE_2D, null);
    return texture2D;
  };

  StaticTexture2D.create_Image = function(url, param) {
    return imagePromise(url).then(function(image) {
      return new Promise(function(resolve, reject) {
        var texture2D;
        param = param || {};
        texture2D = createTexture2DHelper(true, image, param);
        if (!texture2D) {
          return reject(new Error("Create StaticTexture2D ERR."));
        }
        return resolve(texture2D);
      });
    });
  };

  StaticTexture2D.create_Data = function(data, param) {
    var texture2D;
    texture2D = createTexture2DHelper(true, data, param);
    if (!texture2D) {
      throw new Error("Create StaticTexture2D ERR.");
    }
    return texture2D;
  };

  StaticTexture2D.create_Size = function(width, height, param) {
    var texture2D;
    texture2D = createTexture2DHelper(false, width, height, param);
    if (!texture2D) {
      throw new Error("Create StaticTexture2D ERR.");
    }
    return texture2D;
  };

  StaticTexture2D.destory = function(texture2D) {
    if (texture2D._hTexture) {
      webGL.deleteTexture(texture2D._hTexture);
    }
    texture2D._hTexture = null;
    texture2D._width = 0;
    texture2D._height = 0;
    texture2D._format = null;
    texture2D._wrapS = null;
    texture2D._wrapT = null;
    texture2D._magFilter = null;
    texture2D._minFilter = null;
    texture2D._mipMap = false;
  };

  StaticTextureCube = (function() {
    function StaticTextureCube() {
      this._hTexture = null;
      this._width = 0;
      this._height = 0;
      this._format = null;
      this._wrapS = null;
      this._wrapT = null;
      this._magFilter = null;
      this._minFilter = null;
      this._mipMap = false;
      return;
    }

    return StaticTextureCube;

  })();

  createTextureCubeHelper = function(isImageObj) {
    var glFormat, glMemory, height, imageArray, param, ref11, ref12, ref13, ref14, ref15, ref16, textureCube, width;
    if (isImageObj) {
      imageArray = arguments[1];
      param = arguments[2] || {};
    } else {
      width = arguments[1];
      height = arguments[2];
      param = arguments[3] || {};
    }
    textureCube = new StaticTextureCube();
    textureCube._format = (ref11 = param.format) != null ? ref11 : TextureFormat.R8G8B8;
    textureCube._wrapS = (ref12 = param.wrapS) != null ? ref12 : TextureWrap.EDGE;
    textureCube._wrapT = (ref13 = param.wrapT) != null ? ref13 : TextureWrap.EDGE;
    textureCube._magFilter = (ref14 = param.magFilter) != null ? ref14 : TextureFilter.LINEAR;
    textureCube._minFilter = (ref15 = param.minFilter) != null ? ref15 : TextureFilter.LINEAR;
    textureCube._hTexture = webGL.createTexture();
    if (!textureCube._hTexture) {
      return reject(new Error("Create textureCube ERR."));
    }
    webGL.bindTexture(webGL.TEXTURE_CUBE_MAP, textureCube._hTexture);
    ref16 = textureCube._format, glMemory = ref16.glMemory, glFormat = ref16.glFormat;
    if (isImageObj) {
      webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFormat, glFormat, glMemory, imageArray[0]);
      webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFormat, glFormat, glMemory, imageArray[1]);
      webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFormat, glFormat, glMemory, imageArray[2]);
      webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFormat, glFormat, glMemory, imageArray[3]);
      webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFormat, glFormat, glMemory, imageArray[4]);
      webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFormat, glFormat, glMemory, imageArray[5]);
    } else {
      webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, width, height, 0, glFormat, glFormat, glMemory, null);
      webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, width, height, 0, glFormat, glFormat, glMemory, null);
      webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, width, height, 0, glFormat, glFormat, glMemory, null);
      webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, width, height, 0, glFormat, glFormat, glMemory, null);
      webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, width, height, 0, glFormat, glFormat, glMemory, null);
      webGL.texImage2D(webGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, width, height, 0, glFormat, glFormat, glMemory, null);
    }
    webGL.texParameteri(webGL.TEXTURE_CUBE_MAP, webGL.TEXTURE_WRAP_S, textureCube._wrapS.glCode);
    webGL.texParameteri(webGL.TEXTURE_CUBE_MAP, webGL.TEXTURE_WRAP_T, textureCube._wrapT.glCode);
    webGL.texParameteri(webGL.TEXTURE_CUBE_MAP, webGL.TEXTURE_MAG_FILTER, textureCube._magFilter.glCode);
    webGL.texParameteri(webGL.TEXTURE_CUBE_MAP, webGL.TEXTURE_MIN_FILTER, textureCube._minFilter.glCode);
    webGL.bindTexture(webGL.TEXTURE_CUBE_MAP, null);
    return textureCube;
  };

  StaticTextureCube.create_Image = function(urlsArray, param) {
    return Promise.all([imagePromise(urlsArray[0]), imagePromise(urlsArray[1]), imagePromise(urlsArray[2]), imagePromise(urlsArray[3]), imagePromise(urlsArray[4]), imagePromise(urlsArray[5])]).then(function(imageArray) {
      return new Promise(function(resolve, reject) {
        var texture2D;
        param = param || {};
        texture2D = createTextureCubeHelper(true, imageArray, param);
        if (!texture2D) {
          return reject(new Error("Create StaticTexture2D ERR."));
        }
        return resolve(texture2D);
      });
    });
  };

  StaticTextureCube.create_Data = function(dataArray, param) {
    var textureCube;
    textureCube = createTextureCubeHelper(true, dataArray, param);
    if (!textureCube) {
      throw new Error("Create StaticTexture2D ERR.");
    }
    return textureCube;
  };

  StaticTextureCube.create_Size = function(width, height, param) {
    var textureCube;
    textureCube = createTextureCubeHelper(false, width, height, param);
    if (!textureCube) {
      throw new Error("Create StaticTexture2D ERR.");
    }
    return textureCube;
  };

  StaticTextureCube.destory = function() {
    if (textureCube._hTexture) {
      webGL.deleteTexture(textureCube._hTexture);
    }
    textureCube._hTexture = null;
    textureCube._width = 0;
    textureCube._height = 0;
    textureCube._format = null;
    textureCube._wrapS = null;
    textureCube._wrapT = null;
    textureCube._magFilter = null;
    textureCube._minFilter = null;
    textureCube._mipMap = false;
  };

  ti.StaticTexture2D = StaticTexture2D;

  ti.StaticTextureCube = StaticTextureCube;

  decodeObjFile = (function() {
    var CHAR_FLOAT, CHAR_INDEX, CHAR_INT, CHAR_SIZE, CHAR_TABLE, NORMAL_STRIDE, TEXTURE_STRIDE, VERTEX_STRIDE, createContext, ignoreLine, ignoreSpace, parseFloatEx, parseIntEx, parseNormal, parseTexture, parseThird, parseVertex, writeIndex;
    CHAR_INT = 0x1;
    CHAR_INDEX = 0x2;
    CHAR_FLOAT = 0x4;
    CHAR_SIZE = 128;
    CHAR_TABLE = new Uint32Array(CHAR_SIZE);
    CHAR_TABLE[45] = CHAR_FLOAT;
    CHAR_TABLE[46] = CHAR_FLOAT;
    CHAR_TABLE[47] = CHAR_INDEX;
    CHAR_TABLE[48] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;
    CHAR_TABLE[49] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;
    CHAR_TABLE[50] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;
    CHAR_TABLE[51] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;
    CHAR_TABLE[52] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;
    CHAR_TABLE[53] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;
    CHAR_TABLE[54] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;
    CHAR_TABLE[55] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;
    CHAR_TABLE[56] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;
    CHAR_TABLE[57] = CHAR_INT | CHAR_FLOAT | CHAR_INDEX;
    CHAR_TABLE[69] = CHAR_FLOAT;
    CHAR_TABLE[101] = CHAR_FLOAT;
    VERTEX_STRIDE = 3;
    TEXTURE_STRIDE = 2;
    NORMAL_STRIDE = 3;
    createContext = function() {
      return {
        vertex: new Array(512 * VERTEX_STRIDE),
        vertexLen: 0,
        texture: new Array(512 * TEXTURE_STRIDE),
        textureLen: 0,
        normal: new Array(512 * NORMAL_STRIDE),
        normalLen: 0,
        initFlag: false,
        vertexStride: 0,
        textureStride: 0,
        normalStride: 0,
        totalStride: 0,
        vtxBuf: null,
        vtxBufLen: 0,
        idxBuf: null,
        idxBufLen: 0,
        idxMap: Object.create(null)
      };
    };
    ignoreSpace = function(text, ptr) {
      if (' ' !== text[ptr] && '\t' !== text[ptr]) {
        throw new Error();
      }
      ptr = ptr + 1;
      while (' ' === text[ptr] || '\t' === text[ptr]) {
        ptr = ptr + 1;
      }
      return ptr;
    };
    ignoreLine = function(text, ptr) {
      while (void 0 !== text[ptr]) {
        if ('\r' === text[ptr]) {
          if ('\r' !== text[ptr + 1]) {
            ptr = ptr + 1;
          } else {
            ptr = ptr + 2;
          }
          break;
        }
        if ('\n' === text[ptr]) {
          if ('\r' !== text[ptr + 1]) {
            ptr = ptr + 1;
          } else {
            ptr = ptr + 2;
          }
          break;
        }
        ptr = ptr + 1;
      }
      return ptr;
    };
    parseIntEx = (function() {
      var result;
      result = {
        ptr: 0,
        num: 0
      };
      return function(text, ptr) {
        var charCode, start;
        start = ptr;
        charCode = text.charCodeAt(ptr);
        if ((charCode >= CHAR_SIZE) || (0 === (CHAR_INT & CHAR_TABLE[charCode]))) {
          throw new Error();
        }
        ptr = ptr + 1;
        while (true) {
          charCode = text.charCodeAt(ptr);
          if ((charCode >= CHAR_SIZE) || (0 === (CHAR_INT & CHAR_TABLE[charCode]))) {
            break;
          }
          ptr = ptr + 1;
        }
        result.ptr = ptr;
        result.num = parseInt(text.slice(start, ptr));
        return result;
      };
    })();
    parseFloatEx = (function() {
      var result;
      result = {
        ptr: 0,
        num: 0
      };
      return function(text, ptr) {
        var charCode, start;
        start = ptr;
        charCode = text.charCodeAt(ptr);
        if ((charCode >= CHAR_SIZE) || (0 === (CHAR_FLOAT & CHAR_TABLE[charCode]))) {
          throw new Error();
        }
        ptr = ptr + 1;
        while (true) {
          charCode = text.charCodeAt(ptr);
          if ((charCode >= CHAR_SIZE) || (0 === (CHAR_FLOAT & CHAR_TABLE[charCode]))) {
            break;
          }
          ptr = ptr + 1;
        }
        result.ptr = ptr;
        result.num = parseFloat(text.slice(start, ptr));
        return result;
      };
    })();
    parseVertex = (function() {
      var result;
      result = {
        ptr: 0,
        vx: 0,
        vy: 0,
        vz: 0
      };
      return function(text, ptr) {
        var ref11, ref12, ref13;
        ptr = ignoreSpace(text, ptr);
        ref11 = parseFloatEx(text, ptr), result.vx = ref11.num, ptr = ref11.ptr;
        ptr = ignoreSpace(text, ptr);
        ref12 = parseFloatEx(text, ptr), result.vy = ref12.num, ptr = ref12.ptr;
        ptr = ignoreSpace(text, ptr);
        ref13 = parseFloatEx(text, ptr), result.vz = ref13.num, ptr = ref13.ptr;
        result.ptr = ignoreLine(text, ptr);
        return result;
      };
    })();
    parseTexture = (function() {
      var result;
      result = {
        ptr: 0,
        tx: 0,
        ty: 0
      };
      return function(text, ptr) {
        var ref11, ref12;
        ptr = ignoreSpace(text, ptr);
        ref11 = parseFloatEx(text, ptr), result.tx = ref11.num, ptr = ref11.ptr;
        ptr = ignoreSpace(text, ptr);
        ref12 = parseFloatEx(text, ptr), result.ty = ref12.num, ptr = ref12.ptr;
        result.ptr = ignoreLine(text, ptr);
        return result;
      };
    })();
    parseNormal = (function() {
      var result;
      result = {
        ptr: 0,
        nx: 0,
        ny: 0,
        nz: 0
      };
      return function(text, ptr) {
        var ref11, ref12, ref13;
        ptr = ignoreSpace(text, ptr);
        ref11 = parseFloatEx(text, ptr), result.nx = ref11.num, ptr = ref11.ptr;
        ptr = ignoreSpace(text, ptr);
        ref12 = parseFloatEx(text, ptr), result.ny = ref12.num, ptr = ref12.ptr;
        ptr = ignoreSpace(text, ptr);
        ref13 = parseFloatEx(text, ptr), result.nz = ref13.num, ptr = ref13.ptr;
        result.ptr = ignoreLine(text, ptr);
        return result;
      };
    })();
    parseThird = (function() {
      var result;
      result = {
        ptr: 0,
        idxText: ""
      };
      return function(text, ptr) {
        var charCode, start;
        start = ptr;
        while (true) {
          charCode = text.charCodeAt(ptr);
          if (0 === (CHAR_INDEX & CHAR_TABLE[charCode])) {
            break;
          }
          ptr = ptr + 1;
        }
        result.ptr = ptr;
        result.idxText = text.slice(start, ptr);
        if ('' === result.idxText) {
          throw new Error();
        }
        return result;
      };
    })();
    writeIndex = function(ctx, idxText) {
      var ni, numArray, offset, ptr, ref11, ref12, ref13, vi;
      numArray = idxText.split('/');
      if (!ctx.initFlag) {
        ctx.initFlag = true;
        ctx.totalStride = 0;
        if ('' !== numArray[0] && void 0 !== numArray[0]) {
          ctx.vertexStride = VERTEX_STRIDE;
          ctx.totalStride = ctx.totalStride + VERTEX_STRIDE;
        }
        if ('' !== numArray[1] && void 0 !== numArray[1]) {
          ctx.textureStride = TEXTURE_STRIDE;
          ctx.totalStride = ctx.totalStride + TEXTURE_STRIDE;
        }
        if ('' !== numArray[2] && void 0 !== numArray[2]) {
          ctx.normalStride = NORMAL_STRIDE;
          ctx.totalStride = ctx.totalStride + NORMAL_STRIDE;
        }
        ctx.vtxBuf = new Array(ctx.totalStride * 512);
        ctx.idxBuf = new Array(4 * 512);
      }
      if (indexOf.call(ctx.idxMap, idxText) >= 0) {
        ctx.idxBuf[ctx.idxBufLen++] = ctx.idxMap[idxText];
        return;
      }
      ptr = 0;
      offset = 0;
      if (ctx.vertexStride) {
        ref11 = parseIntEx(idxText, ptr), ptr = ref11.ptr, vi = ref11.num;
        vi = vi - 1;
        if (vi > ctx.vertexLen) {
          throw new Error();
        }
        ctx.vtxBuf[ctx.totalStride * ctx.vtxBufLen + offset++] = ctx.vertex[VERTEX_STRIDE * vi + 0];
        ctx.vtxBuf[ctx.totalStride * ctx.vtxBufLen + offset++] = ctx.vertex[VERTEX_STRIDE * vi + 1];
        ctx.vtxBuf[ctx.totalStride * ctx.vtxBufLen + offset++] = ctx.vertex[VERTEX_STRIDE * vi + 2];
      }
      if (ctx.textureStride) {
        if ('/' !== idxText[ptr]) {
          throw new Error();
        }
        ptr = ptr + 1;
        ref12 = parseIntEx(idxText, ptr), ptr = ref12.ptr, ti = ref12.num;
        ti = ti - 1;
        if (ti > ctx.textureLen) {
          throw new Error();
        }
        ctx.vtxBuf[ctx.totalStride * ctx.vtxBufLen + offset++] = ctx.texture[TEXTURE_STRIDE * ti + 0];
        ctx.vtxBuf[ctx.totalStride * ctx.vtxBufLen + offset++] = ctx.texture[TEXTURE_STRIDE * ti + 1];
      }
      if (ctx.normalStride) {
        if ('/' !== idxText[ptr]) {
          throw new Error();
        }
        ptr = ptr + 1;
        if ('/' === idxText[ptr]) {
          ptr = ptr + 1;
        }
        ref13 = parseIntEx(idxText, ptr), ptr = ref13.ptr, ni = ref13.num;
        ni = ni - 1;
        if (ni > ctx.normalLen) {
          throw new Error();
        }
        ctx.vtxBuf[ctx.totalStride * ctx.vtxBufLen + offset++] = ctx.normal[NORMAL_STRIDE * ni + 0];
        ctx.vtxBuf[ctx.totalStride * ctx.vtxBufLen + offset++] = ctx.normal[NORMAL_STRIDE * ni + 1];
        ctx.vtxBuf[ctx.totalStride * ctx.vtxBufLen + offset++] = ctx.normal[NORMAL_STRIDE * ni + 2];
      }
      if (ptr !== idxText.length) {
        throw new Error();
      }
      ctx.idxBuf[ctx.idxBufLen++] = ctx.vtxBufLen;
      ctx.idxMap[idxText] = ctx.vtxBufLen;
      ctx.vtxBufLen = ctx.vtxBufLen + 1;
    };
    decodeObjFile = function(text) {
      var ctx, idxText, nx, ny, nz, ptr, ref11, ref12, ref13, ref14, ref15, ref16, textLen, tx, ty, vx, vy, vz;
      ctx = createContext();
      ptr = 0;
      textLen = text.length;
      while (ptr < textLen) {
        switch (text[ptr]) {
          case 'v':
            ptr = ptr + 1;
            if ('t' === text[ptr]) {
              ptr = ptr + 1;
              ref11 = parseTexture(text, ptr), ptr = ref11.ptr, tx = ref11.tx, ty = ref11.ty;
              ctx.texture[TEXTURE_STRIDE * ctx.textureLen + 0] = tx;
              ctx.texture[TEXTURE_STRIDE * ctx.textureLen + 1] = ty;
              ctx.textureLen = ctx.textureLen + 1;
            } else if ('n' === text[ptr]) {
              ptr = ptr + 1;
              ref12 = parseNormal(text, ptr), ptr = ref12.ptr, nx = ref12.nx, ny = ref12.ny, nz = ref12.nz;
              ctx.normal[NORMAL_STRIDE * ctx.normalLen + 0] = nx;
              ctx.normal[NORMAL_STRIDE * ctx.normalLen + 1] = ny;
              ctx.normal[NORMAL_STRIDE * ctx.normalLen + 2] = nz;
              ctx.normalLen = ctx.normalLen + 1;
            } else {
              ref13 = parseVertex(text, ptr), ptr = ref13.ptr, vx = ref13.vx, vy = ref13.vy, vz = ref13.vz;
              ctx.vertex[VERTEX_STRIDE * ctx.vertexLen + 0] = vx;
              ctx.vertex[VERTEX_STRIDE * ctx.vertexLen + 1] = vy;
              ctx.vertex[VERTEX_STRIDE * ctx.vertexLen + 2] = vz;
              ctx.vertexLen = ctx.vertexLen + 1;
            }
            break;
          case 'f':
            ptr = ptr + 1;
            ptr = ignoreSpace(text, ptr);
            ref14 = parseThird(text, ptr), ptr = ref14.ptr, idxText = ref14.idxText;
            writeIndex(ctx, idxText);
            ptr = ignoreSpace(text, ptr);
            ref15 = parseThird(text, ptr), ptr = ref15.ptr, idxText = ref15.idxText;
            writeIndex(ctx, idxText);
            ptr = ignoreSpace(text, ptr);
            ref16 = parseThird(text, ptr), ptr = ref16.ptr, idxText = ref16.idxText;
            writeIndex(ctx, idxText);
            ptr = ignoreLine(text, ptr);
            break;
          case '#':
            ptr = ignoreLine(text, ptr);
            break;
          case 'g':
            ptr = ptr + 1;
            ptr = ignoreSpace(text, ptr);
            ptr = ignoreLine(text, ptr);
            break;
          case 'o':
            ptr = ptr + 1;
            ptr = ignoreSpace(text, ptr);
            ptr = ignoreLine(text, ptr);
            break;
          case 's':
            ptr = ptr + 1;
            ptr = ignoreSpace(text, ptr);
            ptr = ignoreLine(text, ptr);
            break;
          case 'm':
            if ('mtllib' !== text.slice(ptr, ptr + 6)) {
              throw new Error();
            }
            ptr = ptr + 6;
            ptr = ignoreSpace(text, ptr);
            ptr = ignoreLine(text, ptr);
            break;
          case 'u':
            if ('usemtl' !== text.slice(ptr, ptr + 6)) {
              throw new Error();
            }
            ptr = ptr + 6;
            ptr = ignoreSpace(text, ptr);
            ptr = ignoreLine(text, ptr);
            break;
          case '\r':
          case '\n':
            ptr = ignoreLine(text, ptr);
            break;
          case ' ':
          case '\t':
            ptr = ignoreSpace(text, ptr);
            ptr = ignoreLine(text, ptr);
            break;
          default:
            throw new Error();
        }
      }
      ctx.vtxBuf.length = ctx.vtxBufLen * ctx.totalStride;
      ctx.idxBuf.length = ctx.idxBufLen;
      return {
        vtxBuf: new Float32Array(ctx.vtxBuf),
        idxBuf: new Uint16Array(ctx.idxBuf),
        vertexStride: ctx.vertexStride,
        textureStride: ctx.textureStride,
        normalStride: ctx.normalStride
      };
    };
    return decodeObjFile;
  })();

  DynamicVertex = (function() {
    function DynamicVertex() {
      this._hVertex = null;
      this._size = 0;
      this._usage = null;
      return;
    }

    DynamicVertex.prototype.getUsage = function() {
      return this._usage;
    };

    DynamicVertex.prototype.getSize = function() {
      return this._size;
    };

    return DynamicVertex;

  })();

  DynamicVertex.create_Array = function(array, usage) {
    var vertex;
    vertex = new DynamicVertex();
    vertex._size = array.byteLength;
    vertex._usage = usage;
    vertex._hVertex = webGL.createBuffer();
    if (!vertex._hVertex) {
      throw new Error("Create DynamicVertex ERR.");
    }
    webGL.bindBuffer(webGL.ARRAY_BUFFER, vertex._hVertex);
    webGL.bufferData(webGL.ARRAY_BUFFER, array, vertex._usage.glCode);
    webGL.bindBuffer(webGL.ARRAY_BUFFER, null);
    return vertex;
  };

  DynamicVertex.create_Size = function(size, usage) {
    var vertex;
    vertex = new DynamicVertex();
    vertex._size = size;
    vertex._usage = usage || webGL.STATIC_DRAW;
    vertex._hVertex = webGL.createBuffer();
    if (!vertex._hVertex) {
      throw new Error("Create DynamicVertex ERR.");
    }
    webGL.bindBuffer(webGL.ARRAY_BUFFER, vertex._hVertex);
    webGL.bufferData(webGL.ARRAY_BUFFER, bufferVtc._size, vertex._usage.glCode);
    webGL.bindBuffer(webGL.ARRAY_BUFFER, null);
    return vertex;
  };

  DynamicVertex.destory = function(vertex) {
    if (vertex._hVertex) {
      webGL.deleteBuffer(vertex._hVertex);
    }
    vertex._hVertex = null;
    vertex._usage = null;
    vertex._size = 0;
  };

  DynamicIndex = (function() {
    function DynamicIndex() {
      this._hIndex = null;
      this._usage = null;
      this._size = 0;
      return;
    }

    DynamicIndex.prototype.getUsage = function() {
      return this._usage;
    };

    DynamicIndex.prototype.getSize = function() {
      return this._size;
    };

    return DynamicIndex;

  })();

  DynamicIndex.create_Array = function(array, usage) {
    var index;
    index = new DynamicIndex();
    index._size = array.size;
    index._usage = usage;
    index._hIndex = webGL.createBuffer();
    if (!index._hIndex) {
      throw new Error("Create DynamicIndex ERR.");
    }
    webGL.bindBuffer(webGL.ELEMENT_ARRAY_BUFFER, index._hIndex);
    webGL.bufferData(webGL.ELEMENT_ARRAY_BUFFER, array, index._usage.glCode);
    webGL.bindBuffer(webGL.ELEMENT_ARRAY_BUFFER, null);
    return index;
  };

  DynamicIndex.create_Size = function(size, type, usage) {
    var index;
    index = new DynamicIndex();
    index._usage = usage;
    index._size = size;
    index._hIndex = webGL.createBuffer();
    if (!index._hIndex) {
      throw new Error("Create DynamicIndex ERR.");
    }
    webGL.bindBuffer(webGL.ELEMENT_ARRAY_BUFFER, index._hIndex);
    webGL.bufferData(webGL.ELEMENT_ARRAY_BUFFER, index._size, index._usage);
    webGL.bindBuffer(webGL.ELEMENT_ARRAY_BUFFER, null);
    return index;
  };

  DynamicIndex.destory = function(index) {
    if (index._hIndex) {
      webGL.deleteBuffer(index._hIndex);
    }
    index._hIndex = null;
    index._usage = null;
    index._size = 0;
  };

  StaticMesh = (function() {
    function StaticMesh() {
      this._hVertex = null;
      this._hIndex = null;
      this._usage = BufferUsage.STATIC;
      this._vertexStride = 0;
      this._textureStride = 0;
      this._normalStride = 0;
      this._indexLength = 0;
      return;
    }

    StaticMesh.prototype.getIndexLength = function() {
      return this._indexLength;
    };

    return StaticMesh;

  })();

  StaticMesh.create_ObjFile = function(url) {
    return httpGetPromise(url, null, 'text').then(function(objText) {
      return new Promise(function(resolve, reject) {
        var bufferMesh, objData;
        objData = decodeObjFile(objText);
        bufferMesh = new StaticMesh();
        bufferMesh._vertexStride = objData.vertexStride;
        bufferMesh._textureStride = objData.textureStride;
        bufferMesh._normalStride = objData.normalStride;
        bufferMesh._indexLength = objData.idxBuf.length;
        bufferMesh._hVertex = webGL.createBuffer();
        if (!bufferMesh._hVertex) {
          reject(new Error("Create BufferVtx ERR."));
        }
        webGL.bindBuffer(webGL.ARRAY_BUFFER, bufferMesh._hVertex);
        webGL.bufferData(webGL.ARRAY_BUFFER, objData.vtxBuf, bufferMesh._usage.glCode);
        webGL.bindBuffer(webGL.ARRAY_BUFFER, null);
        bufferMesh._hIndex = webGL.createBuffer();
        if (!bufferMesh._hIndex) {
          reject(new Error("Create DynamicIndex ERR."));
        }
        webGL.bindBuffer(webGL.ELEMENT_ARRAY_BUFFER, bufferMesh._hIndex);
        webGL.bufferData(webGL.ELEMENT_ARRAY_BUFFER, objData.idxBuf, bufferMesh._usage.glCode);
        webGL.bindBuffer(webGL.ELEMENT_ARRAY_BUFFER, null);
        return resolve(bufferMesh);
      });
    });
  };

  StaticMesh.destory = function(bufferMesh) {
    if (bufferMesh._hVertex) {
      webGL.deleteBuffer(bufferMesh._hVertex);
    }
    bufferMesh._hVertex = null;
    if (bufferMesh._hIndex) {
      webGL.deleteBuffer(bufferMesh._hIndex);
    }
    bufferMesh._hIndex = null;
    bufferMesh._usage = BufferUsage.STATIC;
    bufferMesh._vertexStride = 0;
    bufferMesh._textureStride = 0;
    bufferMesh._normalStride = 0;
    bufferMesh._indexLength = 0;
  };

  ti.DynamicVertex = DynamicVertex;

  ti.DynamicIndex = DynamicIndex;

  ti.StaticMesh = StaticMesh;

  glState = {
    clearColorRed: void 0,
    clearColorGreen: void 0,
    clearColorBlue: void 0,
    clearColorAlpha: void 0,
    clearDepth: void 0,
    clearStencil: void 0,
    viewPortOx: void 0,
    viewPortOy: void 0,
    viewPortWidth: void 0,
    viewPortHeight: void 0,
    viewPortNear: void 0,
    viewPortFar: void 0,
    lineWidth: void 0,
    cullEnable: void 0,
    cullFront: void 0,
    cullFace: void 0,
    polygonOffsetEnable: void 0,
    polygonOffsetSlope: void 0,
    polygonOffsetUnit: void 0,
    scissorEnable: void 0,
    scissorOx: void 0,
    scissorOy: void 0,
    scissorWidth: void 0,
    scissorHeight: void 0,
    stencilEnable: void 0,
    stencilFrontWriteMask: void 0,
    stencilFrontReadMask: void 0,
    stencilFrontRefValue: void 0,
    stencilFrontFunc: void 0,
    stencilFrontOptFail: void 0,
    stencilFrontOptZFail: void 0,
    stencilFrontOptPass: void 0,
    stencilBackWriteMask: void 0,
    stencilBackReadMask: void 0,
    stencilBackRefValue: void 0,
    stencilBackFunc: void 0,
    stencilBackOptFail: void 0,
    stencilBackOptZFail: void 0,
    stencilBackOptPass: void 0,
    depthEnable: void 0,
    depthMask: void 0,
    depthFunc: void 0,
    blendEnable: void 0,
    blendRefRed: void 0,
    blendRefGreen: void 0,
    blendRefBlue: void 0,
    blendRefAlpha: void 0,
    blendSrcRGBFunc: void 0,
    blendSrcAlphaFunc: void 0,
    blendDstRGBFunc: void 0,
    blendDstAlphaFunc: void 0,
    blendRGBOpt: void 0,
    blendAlphaOpt: void 0,
    colorMaskRed: void 0,
    colorMaskGreen: void 0,
    colorMaskBlue: void 0,
    colorMaskAlpha: void 0,
    ditherEnable: void 0,
    nowFrame: null,
    nowShader: null,
    nowTexture: 0
  };

  ti.clearFrame = function(param) {
    var clearColorAlpha, clearColorBlue, clearColorGreen, clearColorRed, clearDepth, clearFlag, clearStencil, ref11, ref12, ref13, ref14, ref15, ref16, updateFlag;
    clearColorRed = (ref11 = param.clearColorRed) != null ? ref11 : 0;
    clearColorGreen = (ref12 = param.clearColorGreen) != null ? ref12 : 0;
    clearColorBlue = (ref13 = param.clearColorBlue) != null ? ref13 : 0;
    clearColorAlpha = (ref14 = param.clearColorAlpha) != null ? ref14 : 0;
    updateFlag = glState.clearColorRed !== param.clearColorRed || glState.clearColorGreen !== param.clearColorGreen || glState.clearColorBlue !== param.clearColorBlue || glState.clearColorAlpha !== param.clearColorAlpha;
    if (updateFlag) {
      glState.clearColorRed = param.clearColorRed;
      glState.clearColorGreen = param.clearColorGreen;
      glState.clearColorBlue = param.clearColorBlue;
      glState.clearColorAlpha = param.clearColorAlpha;
      webGL.clearColor(glState.clearColorRed, glState.clearColorGreen, glState.clearColorBlue, glState.clearColorAlpha);
    }
    clearDepth = (ref15 = param.clearDepth) != null ? ref15 : 1.0;
    if (glState.clearDepth !== clearDepth) {
      glState.clearDepth = clearDepth;
      webGL.clearDepth(clearDepth);
    }
    clearStencil = (ref16 = param.clearStencil) != null ? ref16 : 0x00000000;
    if (glState.clearStencil !== clearStencil) {
      glState.clearStencil = clearStencil;
      webGL.clearStencil(clearStencil);
    }
    clearFlag = 0;
    updateFlag = "number" === typeof param.clearColorRed || "number" === typeof param.clearColorGreen || "number" === typeof param.clearColorBlue || "number" === typeof param.clearColorAlpha;
    if (updateFlag) {
      clearFlag |= webGL.COLOR_BUFFER_BIT;
    }
    if ("number" === typeof param.clearDepth) {
      clearFlag |= webGL.DEPTH_BUFFER_BIT;
    }
    if ("number" === typeof param.clearStencil) {
      clearFlag |= webGL.STENCIL_BUFFER_BIT;
    }
    webGL.clear(clearFlag);
  };

  bindAttributeBuffer = function(name, size, stride, offset, data) {
    var varInfo;
    varInfo = glState.nowShader._attributeMap[name];
    if (!varInfo) {
      console.error("Attribute not found <" + name + ">.");
      return;
    }
    webGL.enableVertexAttribArray(varInfo.location);
    webGL.bindBuffer(webGL.ARRAY_BUFFER, data._hVertex);
    webGL.vertexAttribPointer(varInfo.location, size, varInfo.typeInfo.typeCode, false, stride * varInfo.typeInfo.unitBytes, offset * varInfo.typeInfo.unitBytes);
    webGL.bindBuffer(webGL.ARRAY_BUFFER, null);
  };

  bindAttributeConst = function(name, data) {
    var varInfo;
    varInfo = glState.nowShader._attributeMap[name];
    if (!varInfo) {
      console.error("Attribute not found <" + name + ">.");
      return;
    }
    webGL.enableVertexAttribArray(varInfo.location);
    webGL.disableVertexAttribArray(pos);
    switch (varInfo.typeInfo.typeIndex) {
      case 8:
        webGL.vertexAttrib1f(data);
        break;
      case 9:
        webGL.vertexAttrib2fv(data);
        break;
      case 10:
        webGL.vertexAttrib3fv(data);
        break;
      case 11:
        webGL.vertexAttrib4fv(data);
        break;
      default:
        console.error("Unknow attribute type.");
    }
    webGL.bindBuffer(webGL.ARRAY_BUFFER, null);
  };

  bindUniform = function(name, data) {
    var varInfo;
    varInfo = glState.nowShader._uniformMap[name];
    if (!varInfo) {
      console.error("Uniform not found <" + name + ">.");
      return;
    }
    switch (varInfo.typeInfo.typeIndex) {
      case 0:
        if (1 === varInfo.arraySize) {
          webGL.uniform1i(varInfo.location, data);
        } else {
          webGL.uniform1iv(varInfo.location, data);
        }
        break;
      case 1:
        webGL.uniform2iv(varInfo.location, data);
        break;
      case 2:
        webGL.uniform3iv(varInfo.location, data);
        break;
      case 3:
        webGL.uniform4iv(varInfo.location, data);
        break;
      case 4:
        if (1 === varInfo.arraySize) {
          webGL.uniform1i(varInfo.location, data);
        } else {
          webGL.uniform1iv(varInfo.location, data);
        }
        break;
      case 5:
        webGL.uniform2iv(varInfo.location, data);
        break;
      case 6:
        webGL.uniform3iv(varInfo.location, data);
        break;
      case 7:
        webGL.uniform4iv(varInfo.location, data);
        break;
      case 8:
        if (1 === varInfo.arraySize) {
          webGL.uniform1f(varInfo.location, data);
        } else {
          webGL.uniform1fv(varInfo.location, data);
        }
        break;
      case 9:
        webGL.uniform2fv(varInfo.location, data);
        break;
      case 10:
        webGL.uniform3fv(varInfo.location, data);
        break;
      case 11:
        webGL.uniform4fv(varInfo.location, data);
        break;
      case 12:
        webGL.uniformMatrix2fv(varInfo.location, false, data);
        break;
      case 13:
        webGL.uniformMatrix3fv(varInfo.location, false, data);
        break;
      case 14:
        webGL.uniformMatrix4fv(varInfo.location, false, data);
        break;
      case 15:
        webGL.activeTexture(webGL.TEXTURE0 + glState.nowTexture);
        webGL.bindTexture(webGL.TEXTURE_2D, data._hTexture);
        webGL.uniform1i(varInfo.location, glState.nowTexture);
        glState.nowTexture = glState.nowTexture + 1;
        break;
      case 16:
        webGL.activeTexture(webGL.TEXTURE0 + glState.nowTexture);
        webGL.bindTexture(webGL.TEXTURE_CUBE_MAP, data._hTexture);
        webGL.uniform1i(varInfo.location, glState.nowTexture);
        glState.nowTexture = glState.nowTexture + 1;
        break;
      default:
        console.error("Unknow uniform type.");
    }
  };

  ti.drawCall = function(param) {
    var attributeArray, cullEnable, cullFace, cullFront, data, depthEnable, depthFunc, depthMask, drawIndex, drawMode, i, idx, j, k, len, len1, lineWidth, name, offset, polygonOffsetEnable, polygonOffsetSlope, polygonOffsetUnit, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref20, ref21, ref22, ref23, ref24, ref25, ref26, ref27, ref28, ref29, ref30, ref31, ref32, ref33, ref34, ref35, ref36, ref37, ref38, ref39, ref40, ref41, ref42, shader, size, stencilBackFunc, stencilBackOptFail, stencilBackOptPass, stencilBackOptZFail, stencilBackReadMask, stencilBackRefValue, stencilBackWriteMask, stencilEnable, stencilFrontFunc, stencilFrontOpFail, stencilFrontOpPass, stencilFrontOpZFail, stencilFrontReadMask, stencilFrontRefValue, stencilFrontWriteMask, stride, uniformArray, updateFlag, viewPortFar, viewPortHeight, viewPortNear, viewPortOx, viewPortOy, viewPortWidth;
    viewPortOx = (ref11 = param.viewPortOx) != null ? ref11 : 0;
    viewPortOy = (ref12 = param.viewPortOy) != null ? ref12 : 0;
    viewPortWidth = (ref13 = param.viewPortWidth) != null ? ref13 : webGL.drawingBufferWidth;
    viewPortHeight = (ref14 = param.viewPortHeight) != null ? ref14 : webGL.drawingBufferHeight;
    updateFlag = glState.viewPortOx !== viewPortOx || glState.viewPortOy !== viewPortOy || glState.viewPortWidth !== viewPortWidth || glState.viewPortHeight !== viewPortHeight;
    if (updateFlag) {
      glState.viewPortOx = viewPortOx;
      glState.viewPortOy = viewPortOy;
      glState.viewPortWidth = viewPortWidth;
      glState.viewPortHeight = viewPortHeight;
      webGL.viewport(glState.viewPortOx, glState.viewPortOy, glState.viewPortWidth, glState.viewPortHeight);
    }
    viewPortNear = (ref15 = param.viewPortNear) != null ? ref15 : -1;
    viewPortFar = (ref16 = param.viewPortFar) != null ? ref16 : 1;
    updateFlag = glState.viewPortNear !== viewPortNear || glState.viewPortFar !== viewPortFar;
    if (updateFlag) {
      glState.viewPortNear = viewPortNear;
      glState.viewPortFar = viewPortFar;
      webGL.depthRange(glState.viewPortNear, glState.viewPortFar);
    }
    lineWidth = (ref17 = param.lineWidth) != null ? ref17 : 1;
    if (glState.lineWidth !== lineWidth) {
      glState.lineWidth = lineWidth;
      webGL.lineWidth(glState.lineWidth);
    }
    cullEnable = (ref18 = param.cullEnable) != null ? ref18 : true;
    if (glState.cullEnable !== cullEnable) {
      glState.cullEnable = cullEnable;
      if (glState.cullEnable) {
        webGL.enable(webGL.CULL_FACE);
      } else {
        webGL.disable(webGL.CULL_FACE);
      }
    }
    cullFront = (ref19 = param.cullFront) != null ? ref19 : webGL.CCW;
    if (glState.cullFront !== cullFront) {
      glState.cullFront = cullFront;
      webGL.frontFace(glState.cullFront);
    }
    cullFace = (ref20 = param.cullFace) != null ? ref20 : webGL.BACK;
    if (glState.cullFace !== cullFace) {
      glState.cullFace = cullFace;
      webGL.cullFace(glState.cullFace);
    }
    polygonOffsetEnable = (ref21 = glState.polygonOffsetEnable) != null ? ref21 : false;
    if (glState.polygonOffsetEnable !== polygonOffsetEnable) {
      glState.polygonOffsetEnable = polygonOffsetEnable;
      if (glState.polygonOffsetEnable) {
        webGL.enable(webGL.POLYGON_OFFSET_FILL);
      } else {
        webGL.disable(webGL.POLYGON_OFFSET_FILL);
      }
    }
    polygonOffsetSlope = (ref22 = glState.polygonOffsetSlope) != null ? ref22 : 0;
    polygonOffsetUnit = (ref23 = glState.polygonOffsetUnit) != null ? ref23 : 0;
    updateFlag = glState.polygonOffsetSlope !== polygonOffsetSlope || glState.polygonOffsetUnit !== polygonOffsetUnit;
    if (updateFlag) {
      glState.polygonOffsetSlope = polygonOffsetSlope;
      glState.polygonOffsetUnit = polygonOffsetUnit;
      webGL.polygonOffset(glState.polygonOffsetSlope, glState.polygonOffsetUnit);
    }

    /*
    scissorEnable = glState.scissorEnable ? false
    if glState.scissorEnable != scissorEnable
      glState.scissorEnable = scissorEnable
      if glState.scissorEnable
        webGL.enable(webGL.SCISSOR_TEST)
      else
        webGL.disable(webGL.SCISSOR_TEST)
    
    scissorOx = param.scissorOx ? 0
    scissorOy = param.scissorOy ? 0
    scissorWidth = param.scissorWidth ? 0
    scissorHeight = param.scissorHeight ? 0
    updateFlag =
      glState.scissorOx != scissorOx or
      glState.scissorOy != scissorOy or
      glState.scissorWidth != scissorWidth or
      glState.scissorHeight != scissorHeight
    if updateFlag
      glState.scissorOx = scissorOx
      glState.scissorOy = scissorOy
      glState.scissorWidth = scissorWidth
      glState.scissorHeight = scissorHeight
      webGL.scissor(glState.scissorOx, glState.scissorOy, glState.scissorWidth, glState.scissorHeight)
     */
    stencilEnable = (ref24 = glState.stencilEnable) != null ? ref24 : false;
    if (glState.stencilEnable !== stencilEnable) {
      glState.stencilEnable = stencilEnable;
      if (glState.stencilEnable) {
        webGL.enable(webGL.STENCIL_TEST);
      } else {
        webGL.disable(webGL.STENCIL_TEST);
      }
    }
    stencilFrontWriteMask = (ref25 = param.stencilFrontWriteMask) != null ? ref25 : 0xFFFFFFFF;
    if (glState.stencilMaskSeparate !== stencilFrontWriteMask) {
      glState.stencilMaskSeparate = stencilFrontWriteMask;
      webGL.stencilMaskSeparate(webGL.FRONT, glState.stencilMaskSeparate);
    }
    stencilFrontReadMask = (ref26 = glState.stencilFrontReadMask) != null ? ref26 : 0xFFFFFFFF;
    stencilFrontRefValue = (ref27 = glState.stencilFrontRefValue) != null ? ref27 : 0;
    stencilFrontFunc = glState.stencilFrontFunc || webGL.EQUAL;
    updateFlag = glState.stencilFrontReadMask !== stencilFrontReadMask || glState.stencilFrontRefValue !== stencilFrontRefValue || glState.stencilFrontFunc !== stencilFrontFunc;
    if (updateFlag) {
      glState.stencilFrontReadMask = stencilFrontReadMask;
      glState.stencilFrontRefValue = stencilFrontRefValue;
      glState.stencilFrontFunc = stencilFrontFunc;
      webGL.stencilFuncSeparate(webGL.FRONT, glState.stencilFrontFunc, glState.stencilFrontRefValue, glState.stencilFrontReadMask);
    }
    stencilFrontOpFail = (ref28 = glState.stencilFrontOpFail) != null ? ref28 : webGL.KEEP;
    stencilFrontOpZFail = (ref29 = glState.stencilFrontOpZFail) != null ? ref29 : webGL.KEEP;
    stencilFrontOpPass = (ref30 = glState.stencilFrontOpPass) != null ? ref30 : webGL.KEEP;
    updateFlag = glState.stencilFrontOpFail !== stencilFrontOpFail || glState.stencilFrontOpZFail !== stencilFrontOpZFail || glState.stencilFrontOpPass !== stencilFrontOpPass;
    if (updateFlag) {
      glState.stencilFrontOpFail = stencilFrontOpFail;
      glState.stencilFrontOpZFail = stencilFrontOpZFail;
      glState.stencilFrontOpPass = stencilFrontOpPass;
      webGL.stencilOpSeparate(webGL.FRONT, glState.stencilFrontOpFail, glState.stencilFrontOpZFail, glState.stencilFrontOpPass);
    }
    stencilBackWriteMask = (ref31 = param.stencilBackWriteMask) != null ? ref31 : 0xFFFFFFFF;
    if (glState.stencilMaskSeparate !== stencilBackWriteMask) {
      glState.stencilMaskSeparate = stencilBackWriteMask;
      webGL.stencilMaskSeparate(webGL.BACK, glState.stencilMaskSeparate);
    }
    stencilBackReadMask = (ref32 = glState.stencilBackReadMask) != null ? ref32 : 0xFFFFFFFF;
    stencilBackRefValue = (ref33 = glState.stencilBackRefValue) != null ? ref33 : 0;
    stencilBackFunc = glState.stencilBackFunc || webGL.EQUAL;
    updateFlag = glState.stencilBackReadMask !== stencilBackReadMask || glState.stencilBackRefValue !== stencilBackRefValue || glState.stencilBackFunc !== stencilBackFunc;
    if (updateFlag) {
      glState.stencilBackReadMask = stencilBackReadMask;
      glState.stencilBackRefValue = stencilBackRefValue;
      glState.stencilBackFunc = stencilBackFunc;
      webGL.stencilFuncSeparate(webGL.BACK, glState.stencilBackFunc, glState.stencilBackRefValue, glState.stencilBackReadMask);
    }
    stencilBackOptFail = (ref34 = glState.stencilBackOptFail) != null ? ref34 : webGL.KEEP;
    stencilBackOptZFail = (ref35 = glState.stencilBackOptZFail) != null ? ref35 : webGL.KEEP;
    stencilBackOptPass = (ref36 = glState.stencilBackOptPass) != null ? ref36 : webGL.KEEP;
    updateFlag = glState.stencilBackOptFail !== stencilBackOptFail || glState.stencilBackOptZFail !== stencilBackOptZFail || glState.stencilBackOptPass !== stencilBackOptPass;
    if (updateFlag) {
      glState.stencilBackOptFail = stencilBackOptFail;
      glState.stencilBackOptZFail = stencilBackOptZFail;
      glState.stencilBackOptPass = stencilBackOptPass;
      webGL.stencilOpSeparate(webGL.BACK, glState.stencilBackOptFail, glState.stencilBackOptZFail, glState.stencilBackOptPass);
    }
    depthEnable = (ref37 = glState.depthEnable) != null ? ref37 : true;
    if (glState.depthEnable !== depthEnable) {
      glState.depthEnable = depthEnable;
      if (glState.depthEnable) {
        webGL.enable(webGL.DEPTH_TEST);
      } else {
        webGL.disable(webGL.DEPTH_TEST);
      }
    }
    depthMask = (ref38 = glState.depthMask) != null ? ref38 : true;
    if (glState.depthMask !== depthMask) {
      glState.depthMask = depthMask;
      webGL.depthMask(glState.depthMask);
    }
    depthFunc = (ref39 = glState.depthFunc) != null ? ref39 : webGL.LESS;
    if (glState.depthFunc !== depthFunc) {
      glState.depthFunc = depthFunc;
      webGL.depthFunc(glState.depthFunc);
    }

    /*
    blendEnable = glState.blendEnable ? false
    if glState.blendEnable != blendEnable
      glState.blendEnable = blendEnable
      if glState.blendEnable
        webGL.enable(webGL.BLEND)
      else
        webGL.disable(webGL.BLEND)
    
    blendRefRed = glState.blendRefRed ? 0
    blendRefGreen = glState.blendRefGreen ? 0
    blendRefBlue = glState.blendRefBlue ? 0
    blendRefAlpha = glState.blendRefAlpha ? 0
    updateFlag =
      glState.blendRefRed != blendRefRed or
      glState.blendRefGreen != blendRefGreen or
      glState.blendRefBlue != blendRefBlue or
      glState.blendRefAlpha != blendRefAlpha
    if updateFlag
      glState.blendRefRed = blendRefRed
      glState.blendRefGreen = blendRefGreen
      glState.blendRefBlue = blendRefBlue
      glState.blendRefAlpha = blendRefAlpha
      webGL.blendColor(glState.blendRefRed, glState.blendRefGreen, glState.blendRefBlue, glState.blendRefAlpha)
    
    blendSrcRGBFunc = glState.blendSrcRGBFunc ? webGL.SRC_ALPHA
    blendSrcAlphaFunc = glState.blendSrcAlphaFunc ? webGL.SRC_ALPHA
    blendDstRGBFunc = glState.blendDstRGBFunc ? webGL.ONE_MINUS_SRC_ALPHA
    blendDstAlphaFunc = glState.blendDstAlphaFunc ? webGL.ONE_MINUS_SRC_ALPHA
    updateFlag =
      glState.blendSrcRGBFunc != blendSrcRGBFunc or
      glState.blendSrcAlphaFunc != blendSrcAlphaFunc or
      glState.blendDstRGBFunc != blendDstRGBFunc or
      glState.blendDstAlphaFunc != blendDstAlphaFunc
    if updateFlag
      glState.blendSrcRGBFunc = blendSrcRGBFunc
      glState.blendSrcAlphaFunc = blendSrcAlphaFunc
      glState.blendDstRGBFunc = blendDstRGBFunc
      glState.blendDstAlphaFunc = blendDstAlphaFunc
      webGL.blendFuncSeparate(glState.blendSrcRGBFunc, glState.blendSrcAlphaFunc, glState.blendDstRGBFunc, glState.blendDstAlphaFunc)
    
    blendRGBOpt = glState.blendRGBOpt ? webGL.FUNC_ADD
    blendAlphaOpt = glState.blendAlphaOpt ? webGL.FUNC_ADD
    updateFlag =
      glState.blendRGBOpt != blendRGBOpt or
      glState.blendAlphaOpt != blendAlphaOpt
    if updateFlag
      glState.blendRGBOpt = blendRGBOpt
      glState.blendAlphaOpt = blendAlphaOpt
      webGL.blendEquationSeparate(glState.blendRGBOpt, glState.blendAlphaOpt)
    
    colorMaskRed = glState.colorMaskRed ? true
    colorMaskGreen = glState.colorMaskGreen ? true
    colorMaskBlue = glState.colorMaskBlue ? true
    colorMaskAlpha = glState.colorMaskAlpha ? true
    updateFlag =
      glState.colorMaskRed != colorMaskRed or
      glState.colorMaskGreen != colorMaskGreen or
      glState.colorMaskBlue != colorMaskBlue or
      glState.colorMaskAlpha != colorMaskAlpha
    if updateFlag
      glState.colorMaskRed = colorMaskRed
      glState.colorMaskGreen = colorMaskGreen
      glState.colorMaskBlue = colorMaskBlue
      glState.colorMaskAlpha = colorMaskAlpha
      webGL.colorMask(glState.colorMaskRed, glState.colorMaskGreen, glState.colorMaskBlue, glState.colorMaskAlpha)
    
    ditherEnable = glState.ditherEnable ? false
    if glState.ditherEnable != ditherEnable
      glState.ditherEnable = ditherEnable
      if glState.ditherEnable
        webGL.enable(webGL.DITHER)
      else
        webGL.disable(webGL.DITHER)
     */
    shader = param.shader;
    if (!shader) {
      throw new Error("drawCall() Need a shader.");
    }
    webGL.useProgram(shader._hShader);
    glState.nowShader = shader;
    uniformArray = param.uniformArray;
    if (!uniformArray) {
      throw new Error("drawCall() Need a uniformArray.");
    }
    for (i = 0, len = uniformArray.length; i < len; i++) {
      ref40 = uniformArray[i], name = ref40.name, data = ref40.data;
      bindUniform(name, data);
    }
    attributeArray = param.attributeArray;
    if (!attributeArray) {
      throw new Error("drawCall() Need a attributeArray.");
    }
    for (j = 0, len1 = attributeArray.length; j < len1; j++) {
      ref41 = attributeArray[j], name = ref41.name, size = ref41.size, stride = ref41.stride, offset = ref41.offset, data = ref41.data;
      bindAttributeBuffer(name, size, stride, offset, data);
    }
    drawIndex = param.drawIndex, drawMode = param.drawMode;
    if (!drawIndex) {
      webGL.drawArrays(drawMode.glCode, 0, param.drawCount);
    } else {
      webGL.bindBuffer(webGL.ELEMENT_ARRAY_BUFFER, drawIndex._hIndex);
      webGL.drawElements(drawMode.glCode, param.drawCount, webGL.UNSIGNED_SHORT, 0);
      webGL.bindBuffer(webGL.ELEMENT_ARRAY_BUFFER, null);
    }
    for (idx = k = 0, ref42 = glState.nowTexture; k < ref42; idx = k += 1) {
      webGL.activeTexture(webGL.TEXTURE0 + idx);
      webGL.bindTexture(webGL.TEXTURE_2D, null);
      webGL.bindTexture(webGL.TEXTURE_CUBE_MAP, null);
    }
    glState.nowTexture = 0;
    webGL.useProgram(null);
  };

}).call(this);
